// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum tflite_TensorType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case float32 = 0
  case float16 = 1
  case int32 = 2
  case uint8 = 3
  case int64 = 4
  case string = 5
  case bool = 6
  case int16 = 7
  case complex64 = 8
  case int8 = 9
  case float64 = 10
  case complex128 = 11
  case uint64 = 12
  case resource = 13
  case variant = 14
  case uint32 = 15
  case uint16 = 16
  case int4 = 17

  public static var max: tflite_TensorType { return .int4 }
  public static var min: tflite_TensorType { return .float32 }
}


public enum tflite_QuantizationDetails: UInt8, UnionEnum {
  public typealias T = UInt8

  public init?(value: T) {
    self.init(rawValue: value)
  }

  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case none_ = 0
  case customquantization = 1

  public static var max: tflite_QuantizationDetails { return .customquantization }
  public static var min: tflite_QuantizationDetails { return .none_ }
}


public enum tflite_DimensionType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case dense = 0
  case sparseCsr = 1

  public static var max: tflite_DimensionType { return .sparseCsr }
  public static var min: tflite_DimensionType { return .dense }
}


public enum tflite_SparseIndexVector: UInt8, UnionEnum {
  public typealias T = UInt8

  public init?(value: T) {
    self.init(rawValue: value)
  }

  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case none_ = 0
  case int32vector = 1
  case uint16vector = 2
  case uint8vector = 3

  public static var max: tflite_SparseIndexVector { return .uint8vector }
  public static var min: tflite_SparseIndexVector { return .none_ }
}


public enum tflite_BuiltinOperator: Int32, Enum, Verifiable {
  public typealias T = Int32
  public static var byteSize: Int { return MemoryLayout<Int32>.size }
  public var value: Int32 { return self.rawValue }
  case add = 0
  case averagePool2d = 1
  case concatenation = 2
  case conv2d = 3
  case depthwiseConv2d = 4
  case depthToSpace = 5
  case dequantize = 6
  case embeddingLookup = 7
  case floor = 8
  case fullyConnected = 9
  case hashtableLookup = 10
  case l2Normalization = 11
  case l2Pool2d = 12
  case localResponseNormalization = 13
  case logistic = 14
  case lshProjection = 15
  case lstm = 16
  case maxPool2d = 17
  case mul = 18
  case relu = 19
  case reluN1To1 = 20
  case relu6 = 21
  case reshape = 22
  case resizeBilinear = 23
  case rnn = 24
  case softmax = 25
  case spaceToDepth = 26
  case svdf = 27
  case tanh = 28
  case concatEmbeddings = 29
  case skipGram = 30
  case call = 31
  case custom = 32
  case embeddingLookupSparse = 33
  case pad = 34
  case unidirectionalSequenceRnn = 35
  case gather = 36
  case batchToSpaceNd = 37
  case spaceToBatchNd = 38
  case transpose = 39
  case mean = 40
  case sub = 41
  case div = 42
  case squeeze = 43
  case unidirectionalSequenceLstm = 44
  case stridedSlice = 45
  case bidirectionalSequenceRnn = 46
  case exp = 47
  case topkV2 = 48
  case split = 49
  case logSoftmax = 50
  case delegate = 51
  case bidirectionalSequenceLstm = 52
  case cast = 53
  case prelu = 54
  case maximum = 55
  case argMax = 56
  case minimum = 57
  case less = 58
  case neg = 59
  case padv2 = 60
  case greater = 61
  case greaterEqual = 62
  case lessEqual = 63
  case select = 64
  case slice = 65
  case sin = 66
  case transposeConv = 67
  case sparseToDense = 68
  case tile = 69
  case expandDims = 70
  case equal = 71
  case notEqual = 72
  case log = 73
  case sum = 74
  case sqrt = 75
  case rsqrt = 76
  case shape = 77
  case pow = 78
  case argMin = 79
  case fakeQuant = 80
  case reduceProd = 81
  case reduceMax = 82
  case pack = 83
  case logicalOr = 84
  case oneHot = 85
  case logicalAnd = 86
  case logicalNot = 87
  case unpack = 88
  case reduceMin = 89
  case floorDiv = 90
  case reduceAny = 91
  case square = 92
  case zerosLike = 93
  case fill = 94
  case floorMod = 95
  case range = 96
  case resizeNearestNeighbor = 97
  case leakyRelu = 98
  case squaredDifference = 99
  case mirrorPad = 100
  case abs = 101
  case splitV = 102
  case unique = 103
  case ceil = 104
  case reverseV2 = 105
  case addN = 106
  case gatherNd = 107
  case cos = 108
  case where_ = 109
  case rank = 110
  case elu = 111
  case reverseSequence = 112
  case matrixDiag = 113
  case quantize = 114
  case matrixSetDiag = 115
  case round = 116
  case hardSwish = 117
  case if_ = 118
  case while_ = 119
  case nonMaxSuppressionV4 = 120
  case nonMaxSuppressionV5 = 121
  case scatterNd = 122
  case selectV2 = 123
  case densify = 124
  case segmentSum = 125
  case batchMatmul = 126
  case placeholderForGreaterOpCodes = 127
  case cumsum = 128
  case callOnce = 129
  case broadcastTo = 130
  case rfft2d = 131
  case conv3d = 132
  case imag = 133
  case real = 134
  case complexAbs = 135
  case hashtable = 136
  case hashtableFind = 137
  case hashtableImport = 138
  case hashtableSize = 139
  case reduceAll = 140
  case conv3dTranspose = 141
  case varHandle = 142
  case readVariable = 143
  case assignVariable = 144
  case broadcastArgs = 145
  case randomStandardNormal = 146
  case bucketize = 147
  case randomUniform = 148
  case multinomial = 149
  case gelu = 150
  case dynamicUpdateSlice = 151
  case relu0To1 = 152
  case unsortedSegmentProd = 153
  case unsortedSegmentMax = 154
  case unsortedSegmentSum = 155
  case atan2 = 156
  case unsortedSegmentMin = 157
  case sign = 158
  case bitcast = 159
  case bitwiseXor = 160
  case rightShift = 161

  public static var max: tflite_BuiltinOperator { return .rightShift }
  public static var min: tflite_BuiltinOperator { return .add }
}


public enum tflite_BuiltinOptions: UInt8, UnionEnum {
  public typealias T = UInt8

  public init?(value: T) {
    self.init(rawValue: value)
  }

  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case none_ = 0
  case conv2doptions = 1
  case depthwiseconv2doptions = 2
  case concatembeddingsoptions = 3
  case lshprojectionoptions = 4
  case pool2doptions = 5
  case svdfoptions = 6
  case rnnoptions = 7
  case fullyconnectedoptions = 8
  case softmaxoptions = 9
  case concatenationoptions = 10
  case addoptions = 11
  case l2normoptions = 12
  case localresponsenormalizationoptions = 13
  case lstmoptions = 14
  case resizebilinearoptions = 15
  case calloptions = 16
  case reshapeoptions = 17
  case skipgramoptions = 18
  case spacetodepthoptions = 19
  case embeddinglookupsparseoptions = 20
  case muloptions = 21
  case padoptions = 22
  case gatheroptions = 23
  case batchtospacendoptions = 24
  case spacetobatchndoptions = 25
  case transposeoptions = 26
  case reduceroptions = 27
  case suboptions = 28
  case divoptions = 29
  case squeezeoptions = 30
  case sequencernnoptions = 31
  case stridedsliceoptions = 32
  case expoptions = 33
  case topkv2options = 34
  case splitoptions = 35
  case logsoftmaxoptions = 36
  case castoptions = 37
  case dequantizeoptions = 38
  case maximumminimumoptions = 39
  case argmaxoptions = 40
  case lessoptions = 41
  case negoptions = 42
  case padv2options = 43
  case greateroptions = 44
  case greaterequaloptions = 45
  case lessequaloptions = 46
  case selectoptions = 47
  case sliceoptions = 48
  case transposeconvoptions = 49
  case sparsetodenseoptions = 50
  case tileoptions = 51
  case expanddimsoptions = 52
  case equaloptions = 53
  case notequaloptions = 54
  case shapeoptions = 55
  case powoptions = 56
  case argminoptions = 57
  case fakequantoptions = 58
  case packoptions = 59
  case logicaloroptions = 60
  case onehotoptions = 61
  case logicalandoptions = 62
  case logicalnotoptions = 63
  case unpackoptions = 64
  case floordivoptions = 65
  case squareoptions = 66
  case zeroslikeoptions = 67
  case filloptions = 68
  case bidirectionalsequencelstmoptions = 69
  case bidirectionalsequencernnoptions = 70
  case unidirectionalsequencelstmoptions = 71
  case floormodoptions = 72
  case rangeoptions = 73
  case resizenearestneighboroptions = 74
  case leakyreluoptions = 75
  case squareddifferenceoptions = 76
  case mirrorpadoptions = 77
  case absoptions = 78
  case splitvoptions = 79
  case uniqueoptions = 80
  case reversev2options = 81
  case addnoptions = 82
  case gatherndoptions = 83
  case cosoptions = 84
  case whereoptions = 85
  case rankoptions = 86
  case reversesequenceoptions = 87
  case matrixdiagoptions = 88
  case quantizeoptions = 89
  case matrixsetdiagoptions = 90
  case hardswishoptions = 91
  case ifoptions = 92
  case whileoptions = 93
  case depthtospaceoptions = 94
  case nonmaxsuppressionv4options = 95
  case nonmaxsuppressionv5options = 96
  case scatterndoptions = 97
  case selectv2options = 98
  case densifyoptions = 99
  case segmentsumoptions = 100
  case batchmatmuloptions = 101
  case cumsumoptions = 102
  case callonceoptions = 103
  case broadcasttooptions = 104
  case rfft2doptions = 105
  case conv3doptions = 106
  case hashtableoptions = 107
  case hashtablefindoptions = 108
  case hashtableimportoptions = 109
  case hashtablesizeoptions = 110
  case varhandleoptions = 111
  case readvariableoptions = 112
  case assignvariableoptions = 113
  case randomoptions = 114
  case bucketizeoptions = 115
  case geluoptions = 116
  case dynamicupdatesliceoptions = 117
  case unsortedsegmentprodoptions = 118
  case unsortedsegmentmaxoptions = 119
  case unsortedsegmentminoptions = 120
  case unsortedsegmentsumoptions = 121
  case atan2options = 122
  case signoptions = 123
  case bitcastoptions = 124
  case bitwisexoroptions = 125
  case rightshiftoptions = 126

  public static var max: tflite_BuiltinOptions { return .rightshiftoptions }
  public static var min: tflite_BuiltinOptions { return .none_ }
}


public enum tflite_Padding: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case same = 0
  case valid = 1

  public static var max: tflite_Padding { return .valid }
  public static var min: tflite_Padding { return .same }
}


public enum tflite_ActivationFunctionType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case none_ = 0
  case relu = 1
  case reluN1To1 = 2
  case relu6 = 3
  case tanh = 4
  case signBit = 5

  public static var max: tflite_ActivationFunctionType { return .signBit }
  public static var min: tflite_ActivationFunctionType { return .none_ }
}


public enum tflite_LSHProjectionType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case unknown = 0
  case sparse = 1
  case dense = 2

  public static var max: tflite_LSHProjectionType { return .dense }
  public static var min: tflite_LSHProjectionType { return .unknown }
}


public enum tflite_FullyConnectedOptionsWeightsFormat: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case default_ = 0
  case shuffled4x16int8 = 1

  public static var max: tflite_FullyConnectedOptionsWeightsFormat { return .shuffled4x16int8 }
  public static var min: tflite_FullyConnectedOptionsWeightsFormat { return .default_ }
}


public enum tflite_LSTMKernelType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case full = 0
  case basic = 1

  public static var max: tflite_LSTMKernelType { return .basic }
  public static var min: tflite_LSTMKernelType { return .full }
}


public enum tflite_CombinerType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case sum = 0
  case mean = 1
  case sqrtn = 2

  public static var max: tflite_CombinerType { return .sqrtn }
  public static var min: tflite_CombinerType { return .sum }
}


public enum tflite_MirrorPadMode: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case reflect = 0
  case symmetric = 1

  public static var max: tflite_MirrorPadMode { return .symmetric }
  public static var min: tflite_MirrorPadMode { return .reflect }
}


public enum tflite_CustomOptionsFormat: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case flexbuffers = 0

  public static var max: tflite_CustomOptionsFormat { return .flexbuffers }
  public static var min: tflite_CustomOptionsFormat { return .flexbuffers }
}


public struct tflite_CustomQuantization: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_CustomQuantization.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case custom = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasCustom: Bool { let o = _accessor.offset(VTOFFSET.custom.v); return o == 0 ? false : true }
  public var customCount: Int32 { let o = _accessor.offset(VTOFFSET.custom.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func custom(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.custom.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var custom: [UInt8] { return _accessor.getVector(at: VTOFFSET.custom.v) ?? [] }
  public static func startCustomQuantization(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(custom: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: custom, at: VTOFFSET.custom.p) }
  public static func endCustomQuantization(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCustomQuantization(
    _ fbb: inout FlatBufferBuilder,
    customVectorOffset custom: Offset = Offset()
  ) -> Offset {
    let __start = tflite_CustomQuantization.startCustomQuantization(&fbb)
    tflite_CustomQuantization.addVectorOf(custom: custom, &fbb)
    return tflite_CustomQuantization.endCustomQuantization(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.custom.p, fieldName: "custom", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    _v.finish()
  }
}

public struct tflite_QuantizationParameters: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_QuantizationParameters.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case min = 4
    case max = 6
    case scale = 8
    case zeroPoint = 10
    case detailsType = 12
    case details = 14
    case quantizedDimension = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasMin: Bool { let o = _accessor.offset(VTOFFSET.min.v); return o == 0 ? false : true }
  public var minCount: Int32 { let o = _accessor.offset(VTOFFSET.min.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func min(at index: Int32) -> Float32 { let o = _accessor.offset(VTOFFSET.min.v); return o == 0 ? 0 : _accessor.directRead(of: Float32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var min: [Float32] { return _accessor.getVector(at: VTOFFSET.min.v) ?? [] }
  public var hasMax: Bool { let o = _accessor.offset(VTOFFSET.max.v); return o == 0 ? false : true }
  public var maxCount: Int32 { let o = _accessor.offset(VTOFFSET.max.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func max(at index: Int32) -> Float32 { let o = _accessor.offset(VTOFFSET.max.v); return o == 0 ? 0 : _accessor.directRead(of: Float32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var max: [Float32] { return _accessor.getVector(at: VTOFFSET.max.v) ?? [] }
  public var hasScale: Bool { let o = _accessor.offset(VTOFFSET.scale.v); return o == 0 ? false : true }
  public var scaleCount: Int32 { let o = _accessor.offset(VTOFFSET.scale.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func scale(at index: Int32) -> Float32 { let o = _accessor.offset(VTOFFSET.scale.v); return o == 0 ? 0 : _accessor.directRead(of: Float32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var scale: [Float32] { return _accessor.getVector(at: VTOFFSET.scale.v) ?? [] }
  public var hasZeroPoint: Bool { let o = _accessor.offset(VTOFFSET.zeroPoint.v); return o == 0 ? false : true }
  public var zeroPointCount: Int32 { let o = _accessor.offset(VTOFFSET.zeroPoint.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func zeroPoint(at index: Int32) -> Int64 { let o = _accessor.offset(VTOFFSET.zeroPoint.v); return o == 0 ? 0 : _accessor.directRead(of: Int64.self, offset: _accessor.vector(at: o) + index * 8) }
  public var zeroPoint: [Int64] { return _accessor.getVector(at: VTOFFSET.zeroPoint.v) ?? [] }
  public var detailsType: tflite_QuantizationDetails { let o = _accessor.offset(VTOFFSET.detailsType.v); return o == 0 ? .none_ : tflite_QuantizationDetails(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none_ }
  public func details<T: FlatbuffersInitializable>(type: T.Type) -> T? { let o = _accessor.offset(VTOFFSET.details.v); return o == 0 ? nil : _accessor.union(o) }
  public var quantizedDimension: Int32 { let o = _accessor.offset(VTOFFSET.quantizedDimension.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startQuantizationParameters(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  public static func addVectorOf(min: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: min, at: VTOFFSET.min.p) }
  public static func addVectorOf(max: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: max, at: VTOFFSET.max.p) }
  public static func addVectorOf(scale: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: scale, at: VTOFFSET.scale.p) }
  public static func addVectorOf(zeroPoint: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: zeroPoint, at: VTOFFSET.zeroPoint.p) }
  public static func add(detailsType: tflite_QuantizationDetails, _ fbb: inout FlatBufferBuilder) { fbb.add(element: detailsType.rawValue, def: 0, at: VTOFFSET.detailsType.p) }
  public static func add(details: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: details, at: VTOFFSET.details.p) }
  public static func add(quantizedDimension: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: quantizedDimension, def: 0, at: VTOFFSET.quantizedDimension.p) }
  public static func endQuantizationParameters(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createQuantizationParameters(
    _ fbb: inout FlatBufferBuilder,
    minVectorOffset min: Offset = Offset(),
    maxVectorOffset max: Offset = Offset(),
    scaleVectorOffset scale: Offset = Offset(),
    zeroPointVectorOffset zeroPoint: Offset = Offset(),
    detailsType: tflite_QuantizationDetails = .none_,
    detailsOffset details: Offset = Offset(),
    quantizedDimension: Int32 = 0
  ) -> Offset {
    let __start = tflite_QuantizationParameters.startQuantizationParameters(&fbb)
    tflite_QuantizationParameters.addVectorOf(min: min, &fbb)
    tflite_QuantizationParameters.addVectorOf(max: max, &fbb)
    tflite_QuantizationParameters.addVectorOf(scale: scale, &fbb)
    tflite_QuantizationParameters.addVectorOf(zeroPoint: zeroPoint, &fbb)
    tflite_QuantizationParameters.add(detailsType: detailsType, &fbb)
    tflite_QuantizationParameters.add(details: details, &fbb)
    tflite_QuantizationParameters.add(quantizedDimension: quantizedDimension, &fbb)
    return tflite_QuantizationParameters.endQuantizationParameters(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.min.p, fieldName: "min", required: false, type: ForwardOffset<Vector<Float32, Float32>>.self)
    try _v.visit(field: VTOFFSET.max.p, fieldName: "max", required: false, type: ForwardOffset<Vector<Float32, Float32>>.self)
    try _v.visit(field: VTOFFSET.scale.p, fieldName: "scale", required: false, type: ForwardOffset<Vector<Float32, Float32>>.self)
    try _v.visit(field: VTOFFSET.zeroPoint.p, fieldName: "zeroPoint", required: false, type: ForwardOffset<Vector<Int64, Int64>>.self)
    try _v.visit(unionKey: VTOFFSET.detailsType.p, unionField: VTOFFSET.details.p, unionKeyName: "detailsType", fieldName: "details", required: false, completion: { (verifier, key: tflite_QuantizationDetails, pos) in
      switch key {
      case .none_:
        break // NOTE - SWIFT doesnt support none
      case .customquantization:
        try ForwardOffset<tflite_CustomQuantization>.verify(&verifier, at: pos, of: tflite_CustomQuantization.self)
      }
    })
    try _v.visit(field: VTOFFSET.quantizedDimension.p, fieldName: "quantizedDimension", required: false, type: Int32.self)
    _v.finish()
  }
}

public struct tflite_Int32Vector: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_Int32Vector.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case values = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasValues: Bool { let o = _accessor.offset(VTOFFSET.values.v); return o == 0 ? false : true }
  public var valuesCount: Int32 { let o = _accessor.offset(VTOFFSET.values.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func values(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.values.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var values: [Int32] { return _accessor.getVector(at: VTOFFSET.values.v) ?? [] }
  public static func startInt32Vector(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(values: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: values, at: VTOFFSET.values.p) }
  public static func endInt32Vector(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createInt32Vector(
    _ fbb: inout FlatBufferBuilder,
    valuesVectorOffset values: Offset = Offset()
  ) -> Offset {
    let __start = tflite_Int32Vector.startInt32Vector(&fbb)
    tflite_Int32Vector.addVectorOf(values: values, &fbb)
    return tflite_Int32Vector.endInt32Vector(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.values.p, fieldName: "values", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    _v.finish()
  }
}

public struct tflite_Uint16Vector: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_Uint16Vector.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case values = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasValues: Bool { let o = _accessor.offset(VTOFFSET.values.v); return o == 0 ? false : true }
  public var valuesCount: Int32 { let o = _accessor.offset(VTOFFSET.values.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func values(at index: Int32) -> UInt16 { let o = _accessor.offset(VTOFFSET.values.v); return o == 0 ? 0 : _accessor.directRead(of: UInt16.self, offset: _accessor.vector(at: o) + index * 2) }
  public var values: [UInt16] { return _accessor.getVector(at: VTOFFSET.values.v) ?? [] }
  public static func startUint16Vector(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(values: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: values, at: VTOFFSET.values.p) }
  public static func endUint16Vector(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createUint16Vector(
    _ fbb: inout FlatBufferBuilder,
    valuesVectorOffset values: Offset = Offset()
  ) -> Offset {
    let __start = tflite_Uint16Vector.startUint16Vector(&fbb)
    tflite_Uint16Vector.addVectorOf(values: values, &fbb)
    return tflite_Uint16Vector.endUint16Vector(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.values.p, fieldName: "values", required: false, type: ForwardOffset<Vector<UInt16, UInt16>>.self)
    _v.finish()
  }
}

public struct tflite_Uint8Vector: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_Uint8Vector.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case values = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasValues: Bool { let o = _accessor.offset(VTOFFSET.values.v); return o == 0 ? false : true }
  public var valuesCount: Int32 { let o = _accessor.offset(VTOFFSET.values.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func values(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.values.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var values: [UInt8] { return _accessor.getVector(at: VTOFFSET.values.v) ?? [] }
  public static func startUint8Vector(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(values: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: values, at: VTOFFSET.values.p) }
  public static func endUint8Vector(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createUint8Vector(
    _ fbb: inout FlatBufferBuilder,
    valuesVectorOffset values: Offset = Offset()
  ) -> Offset {
    let __start = tflite_Uint8Vector.startUint8Vector(&fbb)
    tflite_Uint8Vector.addVectorOf(values: values, &fbb)
    return tflite_Uint8Vector.endUint8Vector(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.values.p, fieldName: "values", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    _v.finish()
  }
}

public struct tflite_DimensionMetadata: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_DimensionMetadata.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case format = 4
    case denseSize = 6
    case arraySegmentsType = 8
    case arraySegments = 10
    case arrayIndicesType = 12
    case arrayIndices = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var format: tflite_DimensionType { let o = _accessor.offset(VTOFFSET.format.v); return o == 0 ? .dense : tflite_DimensionType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .dense }
  public var denseSize: Int32 { let o = _accessor.offset(VTOFFSET.denseSize.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var arraySegmentsType: tflite_SparseIndexVector { let o = _accessor.offset(VTOFFSET.arraySegmentsType.v); return o == 0 ? .none_ : tflite_SparseIndexVector(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none_ }
  public func arraySegments<T: FlatbuffersInitializable>(type: T.Type) -> T? { let o = _accessor.offset(VTOFFSET.arraySegments.v); return o == 0 ? nil : _accessor.union(o) }
  public var arrayIndicesType: tflite_SparseIndexVector { let o = _accessor.offset(VTOFFSET.arrayIndicesType.v); return o == 0 ? .none_ : tflite_SparseIndexVector(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none_ }
  public func arrayIndices<T: FlatbuffersInitializable>(type: T.Type) -> T? { let o = _accessor.offset(VTOFFSET.arrayIndices.v); return o == 0 ? nil : _accessor.union(o) }
  public static func startDimensionMetadata(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(format: tflite_DimensionType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: format.rawValue, def: 0, at: VTOFFSET.format.p) }
  public static func add(denseSize: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: denseSize, def: 0, at: VTOFFSET.denseSize.p) }
  public static func add(arraySegmentsType: tflite_SparseIndexVector, _ fbb: inout FlatBufferBuilder) { fbb.add(element: arraySegmentsType.rawValue, def: 0, at: VTOFFSET.arraySegmentsType.p) }
  public static func add(arraySegments: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: arraySegments, at: VTOFFSET.arraySegments.p) }
  public static func add(arrayIndicesType: tflite_SparseIndexVector, _ fbb: inout FlatBufferBuilder) { fbb.add(element: arrayIndicesType.rawValue, def: 0, at: VTOFFSET.arrayIndicesType.p) }
  public static func add(arrayIndices: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: arrayIndices, at: VTOFFSET.arrayIndices.p) }
  public static func endDimensionMetadata(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createDimensionMetadata(
    _ fbb: inout FlatBufferBuilder,
    format: tflite_DimensionType = .dense,
    denseSize: Int32 = 0,
    arraySegmentsType: tflite_SparseIndexVector = .none_,
    arraySegmentsOffset arraySegments: Offset = Offset(),
    arrayIndicesType: tflite_SparseIndexVector = .none_,
    arrayIndicesOffset arrayIndices: Offset = Offset()
  ) -> Offset {
    let __start = tflite_DimensionMetadata.startDimensionMetadata(&fbb)
    tflite_DimensionMetadata.add(format: format, &fbb)
    tflite_DimensionMetadata.add(denseSize: denseSize, &fbb)
    tflite_DimensionMetadata.add(arraySegmentsType: arraySegmentsType, &fbb)
    tflite_DimensionMetadata.add(arraySegments: arraySegments, &fbb)
    tflite_DimensionMetadata.add(arrayIndicesType: arrayIndicesType, &fbb)
    tflite_DimensionMetadata.add(arrayIndices: arrayIndices, &fbb)
    return tflite_DimensionMetadata.endDimensionMetadata(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.format.p, fieldName: "format", required: false, type: tflite_DimensionType.self)
    try _v.visit(field: VTOFFSET.denseSize.p, fieldName: "denseSize", required: false, type: Int32.self)
    try _v.visit(unionKey: VTOFFSET.arraySegmentsType.p, unionField: VTOFFSET.arraySegments.p, unionKeyName: "arraySegmentsType", fieldName: "arraySegments", required: false, completion: { (verifier, key: tflite_SparseIndexVector, pos) in
      switch key {
      case .none_:
        break // NOTE - SWIFT doesnt support none
      case .int32vector:
        try ForwardOffset<tflite_Int32Vector>.verify(&verifier, at: pos, of: tflite_Int32Vector.self)
      case .uint16vector:
        try ForwardOffset<tflite_Uint16Vector>.verify(&verifier, at: pos, of: tflite_Uint16Vector.self)
      case .uint8vector:
        try ForwardOffset<tflite_Uint8Vector>.verify(&verifier, at: pos, of: tflite_Uint8Vector.self)
      }
    })
    try _v.visit(unionKey: VTOFFSET.arrayIndicesType.p, unionField: VTOFFSET.arrayIndices.p, unionKeyName: "arrayIndicesType", fieldName: "arrayIndices", required: false, completion: { (verifier, key: tflite_SparseIndexVector, pos) in
      switch key {
      case .none_:
        break // NOTE - SWIFT doesnt support none
      case .int32vector:
        try ForwardOffset<tflite_Int32Vector>.verify(&verifier, at: pos, of: tflite_Int32Vector.self)
      case .uint16vector:
        try ForwardOffset<tflite_Uint16Vector>.verify(&verifier, at: pos, of: tflite_Uint16Vector.self)
      case .uint8vector:
        try ForwardOffset<tflite_Uint8Vector>.verify(&verifier, at: pos, of: tflite_Uint8Vector.self)
      }
    })
    _v.finish()
  }
}

public struct tflite_SparsityParameters: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_SparsityParameters.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case traversalOrder = 4
    case blockMap = 6
    case dimMetadata = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasTraversalOrder: Bool { let o = _accessor.offset(VTOFFSET.traversalOrder.v); return o == 0 ? false : true }
  public var traversalOrderCount: Int32 { let o = _accessor.offset(VTOFFSET.traversalOrder.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func traversalOrder(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.traversalOrder.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var traversalOrder: [Int32] { return _accessor.getVector(at: VTOFFSET.traversalOrder.v) ?? [] }
  public var hasBlockMap: Bool { let o = _accessor.offset(VTOFFSET.blockMap.v); return o == 0 ? false : true }
  public var blockMapCount: Int32 { let o = _accessor.offset(VTOFFSET.blockMap.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func blockMap(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.blockMap.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var blockMap: [Int32] { return _accessor.getVector(at: VTOFFSET.blockMap.v) ?? [] }
  public var hasDimMetadata: Bool { let o = _accessor.offset(VTOFFSET.dimMetadata.v); return o == 0 ? false : true }
  public var dimMetadataCount: Int32 { let o = _accessor.offset(VTOFFSET.dimMetadata.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func dimMetadata(at index: Int32) -> tflite_DimensionMetadata? { let o = _accessor.offset(VTOFFSET.dimMetadata.v); return o == 0 ? nil : tflite_DimensionMetadata(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startSparsityParameters(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func addVectorOf(traversalOrder: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: traversalOrder, at: VTOFFSET.traversalOrder.p) }
  public static func addVectorOf(blockMap: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: blockMap, at: VTOFFSET.blockMap.p) }
  public static func addVectorOf(dimMetadata: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: dimMetadata, at: VTOFFSET.dimMetadata.p) }
  public static func endSparsityParameters(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSparsityParameters(
    _ fbb: inout FlatBufferBuilder,
    traversalOrderVectorOffset traversalOrder: Offset = Offset(),
    blockMapVectorOffset blockMap: Offset = Offset(),
    dimMetadataVectorOffset dimMetadata: Offset = Offset()
  ) -> Offset {
    let __start = tflite_SparsityParameters.startSparsityParameters(&fbb)
    tflite_SparsityParameters.addVectorOf(traversalOrder: traversalOrder, &fbb)
    tflite_SparsityParameters.addVectorOf(blockMap: blockMap, &fbb)
    tflite_SparsityParameters.addVectorOf(dimMetadata: dimMetadata, &fbb)
    return tflite_SparsityParameters.endSparsityParameters(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.traversalOrder.p, fieldName: "traversalOrder", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(field: VTOFFSET.blockMap.p, fieldName: "blockMap", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(field: VTOFFSET.dimMetadata.p, fieldName: "dimMetadata", required: false, type: ForwardOffset<Vector<ForwardOffset<tflite_DimensionMetadata>, tflite_DimensionMetadata>>.self)
    _v.finish()
  }
}

public struct tflite_VariantSubType: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_VariantSubType.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case shape = 4
    case type = 6
    case hasRank = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasShape: Bool { let o = _accessor.offset(VTOFFSET.shape.v); return o == 0 ? false : true }
  public var shapeCount: Int32 { let o = _accessor.offset(VTOFFSET.shape.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func shape(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.shape.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var shape: [Int32] { return _accessor.getVector(at: VTOFFSET.shape.v) ?? [] }
  public var type: tflite_TensorType { let o = _accessor.offset(VTOFFSET.type.v); return o == 0 ? .float32 : tflite_TensorType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .float32 }
  public var hasRank: Bool { let o = _accessor.offset(VTOFFSET.hasRank.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startVariantSubType(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func addVectorOf(shape: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: shape, at: VTOFFSET.shape.p) }
  public static func add(type: tflite_TensorType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: type.rawValue, def: 0, at: VTOFFSET.type.p) }
  public static func add(hasRank: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hasRank, def: false,
   at: VTOFFSET.hasRank.p) }
  public static func endVariantSubType(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createVariantSubType(
    _ fbb: inout FlatBufferBuilder,
    shapeVectorOffset shape: Offset = Offset(),
    type: tflite_TensorType = .float32,
    hasRank: Bool = false
  ) -> Offset {
    let __start = tflite_VariantSubType.startVariantSubType(&fbb)
    tflite_VariantSubType.addVectorOf(shape: shape, &fbb)
    tflite_VariantSubType.add(type: type, &fbb)
    tflite_VariantSubType.add(hasRank: hasRank, &fbb)
    return tflite_VariantSubType.endVariantSubType(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.shape.p, fieldName: "shape", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(field: VTOFFSET.type.p, fieldName: "type", required: false, type: tflite_TensorType.self)
    try _v.visit(field: VTOFFSET.hasRank.p, fieldName: "hasRank", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct tflite_Tensor: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_Tensor.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case shape = 4
    case type = 6
    case buffer = 8
    case name = 10
    case quantization = 12
    case isVariable = 14
    case sparsity = 16
    case shapeSignature = 18
    case hasRank = 20
    case variantTensors = 22
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasShape: Bool { let o = _accessor.offset(VTOFFSET.shape.v); return o == 0 ? false : true }
  public var shapeCount: Int32 { let o = _accessor.offset(VTOFFSET.shape.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func shape(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.shape.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var shape: [Int32] { return _accessor.getVector(at: VTOFFSET.shape.v) ?? [] }
  public var type: tflite_TensorType { let o = _accessor.offset(VTOFFSET.type.v); return o == 0 ? .float32 : tflite_TensorType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .float32 }
  public var buffer: UInt32 { let o = _accessor.offset(VTOFFSET.buffer.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  public var quantization: tflite_QuantizationParameters? { let o = _accessor.offset(VTOFFSET.quantization.v); return o == 0 ? nil : tflite_QuantizationParameters(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public var isVariable: Bool { let o = _accessor.offset(VTOFFSET.isVariable.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var sparsity: tflite_SparsityParameters? { let o = _accessor.offset(VTOFFSET.sparsity.v); return o == 0 ? nil : tflite_SparsityParameters(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public var hasShapeSignature: Bool { let o = _accessor.offset(VTOFFSET.shapeSignature.v); return o == 0 ? false : true }
  public var shapeSignatureCount: Int32 { let o = _accessor.offset(VTOFFSET.shapeSignature.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func shapeSignature(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.shapeSignature.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var shapeSignature: [Int32] { return _accessor.getVector(at: VTOFFSET.shapeSignature.v) ?? [] }
  public var hasRank: Bool { let o = _accessor.offset(VTOFFSET.hasRank.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var hasVariantTensors: Bool { let o = _accessor.offset(VTOFFSET.variantTensors.v); return o == 0 ? false : true }
  public var variantTensorsCount: Int32 { let o = _accessor.offset(VTOFFSET.variantTensors.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func variantTensors(at index: Int32) -> tflite_VariantSubType? { let o = _accessor.offset(VTOFFSET.variantTensors.v); return o == 0 ? nil : tflite_VariantSubType(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startTensor(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 10) }
  public static func addVectorOf(shape: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: shape, at: VTOFFSET.shape.p) }
  public static func add(type: tflite_TensorType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: type.rawValue, def: 0, at: VTOFFSET.type.p) }
  public static func add(buffer: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: buffer, def: 0, at: VTOFFSET.buffer.p) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func add(quantization: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: quantization, at: VTOFFSET.quantization.p) }
  public static func add(isVariable: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: isVariable, def: false,
   at: VTOFFSET.isVariable.p) }
  public static func add(sparsity: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sparsity, at: VTOFFSET.sparsity.p) }
  public static func addVectorOf(shapeSignature: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: shapeSignature, at: VTOFFSET.shapeSignature.p) }
  public static func add(hasRank: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hasRank, def: false,
   at: VTOFFSET.hasRank.p) }
  public static func addVectorOf(variantTensors: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: variantTensors, at: VTOFFSET.variantTensors.p) }
  public static func endTensor(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createTensor(
    _ fbb: inout FlatBufferBuilder,
    shapeVectorOffset shape: Offset = Offset(),
    type: tflite_TensorType = .float32,
    buffer: UInt32 = 0,
    nameOffset name: Offset = Offset(),
    quantizationOffset quantization: Offset = Offset(),
    isVariable: Bool = false,
    sparsityOffset sparsity: Offset = Offset(),
    shapeSignatureVectorOffset shapeSignature: Offset = Offset(),
    hasRank: Bool = false,
    variantTensorsVectorOffset variantTensors: Offset = Offset()
  ) -> Offset {
    let __start = tflite_Tensor.startTensor(&fbb)
    tflite_Tensor.addVectorOf(shape: shape, &fbb)
    tflite_Tensor.add(type: type, &fbb)
    tflite_Tensor.add(buffer: buffer, &fbb)
    tflite_Tensor.add(name: name, &fbb)
    tflite_Tensor.add(quantization: quantization, &fbb)
    tflite_Tensor.add(isVariable: isVariable, &fbb)
    tflite_Tensor.add(sparsity: sparsity, &fbb)
    tflite_Tensor.addVectorOf(shapeSignature: shapeSignature, &fbb)
    tflite_Tensor.add(hasRank: hasRank, &fbb)
    tflite_Tensor.addVectorOf(variantTensors: variantTensors, &fbb)
    return tflite_Tensor.endTensor(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.shape.p, fieldName: "shape", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(field: VTOFFSET.type.p, fieldName: "type", required: false, type: tflite_TensorType.self)
    try _v.visit(field: VTOFFSET.buffer.p, fieldName: "buffer", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.quantization.p, fieldName: "quantization", required: false, type: ForwardOffset<tflite_QuantizationParameters>.self)
    try _v.visit(field: VTOFFSET.isVariable.p, fieldName: "isVariable", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.sparsity.p, fieldName: "sparsity", required: false, type: ForwardOffset<tflite_SparsityParameters>.self)
    try _v.visit(field: VTOFFSET.shapeSignature.p, fieldName: "shapeSignature", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(field: VTOFFSET.hasRank.p, fieldName: "hasRank", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.variantTensors.p, fieldName: "variantTensors", required: false, type: ForwardOffset<Vector<ForwardOffset<tflite_VariantSubType>, tflite_VariantSubType>>.self)
    _v.finish()
  }
}

public struct tflite_Conv2DOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_Conv2DOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case padding = 4
    case strideW = 6
    case strideH = 8
    case fusedActivationFunction = 10
    case dilationWFactor = 12
    case dilationHFactor = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var padding: tflite_Padding { let o = _accessor.offset(VTOFFSET.padding.v); return o == 0 ? .same : tflite_Padding(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .same }
  public var strideW: Int32 { let o = _accessor.offset(VTOFFSET.strideW.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var strideH: Int32 { let o = _accessor.offset(VTOFFSET.strideH.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var fusedActivationFunction: tflite_ActivationFunctionType { let o = _accessor.offset(VTOFFSET.fusedActivationFunction.v); return o == 0 ? .none_ : tflite_ActivationFunctionType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public var dilationWFactor: Int32 { let o = _accessor.offset(VTOFFSET.dilationWFactor.v); return o == 0 ? 1 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var dilationHFactor: Int32 { let o = _accessor.offset(VTOFFSET.dilationHFactor.v); return o == 0 ? 1 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startConv2DOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(padding: tflite_Padding, _ fbb: inout FlatBufferBuilder) { fbb.add(element: padding.rawValue, def: 0, at: VTOFFSET.padding.p) }
  public static func add(strideW: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: strideW, def: 0, at: VTOFFSET.strideW.p) }
  public static func add(strideH: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: strideH, def: 0, at: VTOFFSET.strideH.p) }
  public static func add(fusedActivationFunction: tflite_ActivationFunctionType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fusedActivationFunction.rawValue, def: 0, at: VTOFFSET.fusedActivationFunction.p) }
  public static func add(dilationWFactor: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dilationWFactor, def: 1, at: VTOFFSET.dilationWFactor.p) }
  public static func add(dilationHFactor: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dilationHFactor, def: 1, at: VTOFFSET.dilationHFactor.p) }
  public static func endConv2DOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createConv2DOptions(
    _ fbb: inout FlatBufferBuilder,
    padding: tflite_Padding = .same,
    strideW: Int32 = 0,
    strideH: Int32 = 0,
    fusedActivationFunction: tflite_ActivationFunctionType = .none_,
    dilationWFactor: Int32 = 1,
    dilationHFactor: Int32 = 1
  ) -> Offset {
    let __start = tflite_Conv2DOptions.startConv2DOptions(&fbb)
    tflite_Conv2DOptions.add(padding: padding, &fbb)
    tflite_Conv2DOptions.add(strideW: strideW, &fbb)
    tflite_Conv2DOptions.add(strideH: strideH, &fbb)
    tflite_Conv2DOptions.add(fusedActivationFunction: fusedActivationFunction, &fbb)
    tflite_Conv2DOptions.add(dilationWFactor: dilationWFactor, &fbb)
    tflite_Conv2DOptions.add(dilationHFactor: dilationHFactor, &fbb)
    return tflite_Conv2DOptions.endConv2DOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.padding.p, fieldName: "padding", required: false, type: tflite_Padding.self)
    try _v.visit(field: VTOFFSET.strideW.p, fieldName: "strideW", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.strideH.p, fieldName: "strideH", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.fusedActivationFunction.p, fieldName: "fusedActivationFunction", required: false, type: tflite_ActivationFunctionType.self)
    try _v.visit(field: VTOFFSET.dilationWFactor.p, fieldName: "dilationWFactor", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.dilationHFactor.p, fieldName: "dilationHFactor", required: false, type: Int32.self)
    _v.finish()
  }
}

public struct tflite_Conv3DOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_Conv3DOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case padding = 4
    case strideD = 6
    case strideW = 8
    case strideH = 10
    case fusedActivationFunction = 12
    case dilationDFactor = 14
    case dilationWFactor = 16
    case dilationHFactor = 18
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var padding: tflite_Padding { let o = _accessor.offset(VTOFFSET.padding.v); return o == 0 ? .same : tflite_Padding(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .same }
  public var strideD: Int32 { let o = _accessor.offset(VTOFFSET.strideD.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var strideW: Int32 { let o = _accessor.offset(VTOFFSET.strideW.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var strideH: Int32 { let o = _accessor.offset(VTOFFSET.strideH.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var fusedActivationFunction: tflite_ActivationFunctionType { let o = _accessor.offset(VTOFFSET.fusedActivationFunction.v); return o == 0 ? .none_ : tflite_ActivationFunctionType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public var dilationDFactor: Int32 { let o = _accessor.offset(VTOFFSET.dilationDFactor.v); return o == 0 ? 1 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var dilationWFactor: Int32 { let o = _accessor.offset(VTOFFSET.dilationWFactor.v); return o == 0 ? 1 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var dilationHFactor: Int32 { let o = _accessor.offset(VTOFFSET.dilationHFactor.v); return o == 0 ? 1 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startConv3DOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 8) }
  public static func add(padding: tflite_Padding, _ fbb: inout FlatBufferBuilder) { fbb.add(element: padding.rawValue, def: 0, at: VTOFFSET.padding.p) }
  public static func add(strideD: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: strideD, def: 0, at: VTOFFSET.strideD.p) }
  public static func add(strideW: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: strideW, def: 0, at: VTOFFSET.strideW.p) }
  public static func add(strideH: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: strideH, def: 0, at: VTOFFSET.strideH.p) }
  public static func add(fusedActivationFunction: tflite_ActivationFunctionType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fusedActivationFunction.rawValue, def: 0, at: VTOFFSET.fusedActivationFunction.p) }
  public static func add(dilationDFactor: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dilationDFactor, def: 1, at: VTOFFSET.dilationDFactor.p) }
  public static func add(dilationWFactor: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dilationWFactor, def: 1, at: VTOFFSET.dilationWFactor.p) }
  public static func add(dilationHFactor: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dilationHFactor, def: 1, at: VTOFFSET.dilationHFactor.p) }
  public static func endConv3DOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createConv3DOptions(
    _ fbb: inout FlatBufferBuilder,
    padding: tflite_Padding = .same,
    strideD: Int32 = 0,
    strideW: Int32 = 0,
    strideH: Int32 = 0,
    fusedActivationFunction: tflite_ActivationFunctionType = .none_,
    dilationDFactor: Int32 = 1,
    dilationWFactor: Int32 = 1,
    dilationHFactor: Int32 = 1
  ) -> Offset {
    let __start = tflite_Conv3DOptions.startConv3DOptions(&fbb)
    tflite_Conv3DOptions.add(padding: padding, &fbb)
    tflite_Conv3DOptions.add(strideD: strideD, &fbb)
    tflite_Conv3DOptions.add(strideW: strideW, &fbb)
    tflite_Conv3DOptions.add(strideH: strideH, &fbb)
    tflite_Conv3DOptions.add(fusedActivationFunction: fusedActivationFunction, &fbb)
    tflite_Conv3DOptions.add(dilationDFactor: dilationDFactor, &fbb)
    tflite_Conv3DOptions.add(dilationWFactor: dilationWFactor, &fbb)
    tflite_Conv3DOptions.add(dilationHFactor: dilationHFactor, &fbb)
    return tflite_Conv3DOptions.endConv3DOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.padding.p, fieldName: "padding", required: false, type: tflite_Padding.self)
    try _v.visit(field: VTOFFSET.strideD.p, fieldName: "strideD", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.strideW.p, fieldName: "strideW", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.strideH.p, fieldName: "strideH", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.fusedActivationFunction.p, fieldName: "fusedActivationFunction", required: false, type: tflite_ActivationFunctionType.self)
    try _v.visit(field: VTOFFSET.dilationDFactor.p, fieldName: "dilationDFactor", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.dilationWFactor.p, fieldName: "dilationWFactor", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.dilationHFactor.p, fieldName: "dilationHFactor", required: false, type: Int32.self)
    _v.finish()
  }
}

public struct tflite_Pool2DOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_Pool2DOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case padding = 4
    case strideW = 6
    case strideH = 8
    case filterWidth = 10
    case filterHeight = 12
    case fusedActivationFunction = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var padding: tflite_Padding { let o = _accessor.offset(VTOFFSET.padding.v); return o == 0 ? .same : tflite_Padding(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .same }
  public var strideW: Int32 { let o = _accessor.offset(VTOFFSET.strideW.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var strideH: Int32 { let o = _accessor.offset(VTOFFSET.strideH.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var filterWidth: Int32 { let o = _accessor.offset(VTOFFSET.filterWidth.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var filterHeight: Int32 { let o = _accessor.offset(VTOFFSET.filterHeight.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var fusedActivationFunction: tflite_ActivationFunctionType { let o = _accessor.offset(VTOFFSET.fusedActivationFunction.v); return o == 0 ? .none_ : tflite_ActivationFunctionType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public static func startPool2DOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(padding: tflite_Padding, _ fbb: inout FlatBufferBuilder) { fbb.add(element: padding.rawValue, def: 0, at: VTOFFSET.padding.p) }
  public static func add(strideW: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: strideW, def: 0, at: VTOFFSET.strideW.p) }
  public static func add(strideH: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: strideH, def: 0, at: VTOFFSET.strideH.p) }
  public static func add(filterWidth: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: filterWidth, def: 0, at: VTOFFSET.filterWidth.p) }
  public static func add(filterHeight: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: filterHeight, def: 0, at: VTOFFSET.filterHeight.p) }
  public static func add(fusedActivationFunction: tflite_ActivationFunctionType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fusedActivationFunction.rawValue, def: 0, at: VTOFFSET.fusedActivationFunction.p) }
  public static func endPool2DOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPool2DOptions(
    _ fbb: inout FlatBufferBuilder,
    padding: tflite_Padding = .same,
    strideW: Int32 = 0,
    strideH: Int32 = 0,
    filterWidth: Int32 = 0,
    filterHeight: Int32 = 0,
    fusedActivationFunction: tflite_ActivationFunctionType = .none_
  ) -> Offset {
    let __start = tflite_Pool2DOptions.startPool2DOptions(&fbb)
    tflite_Pool2DOptions.add(padding: padding, &fbb)
    tflite_Pool2DOptions.add(strideW: strideW, &fbb)
    tflite_Pool2DOptions.add(strideH: strideH, &fbb)
    tflite_Pool2DOptions.add(filterWidth: filterWidth, &fbb)
    tflite_Pool2DOptions.add(filterHeight: filterHeight, &fbb)
    tflite_Pool2DOptions.add(fusedActivationFunction: fusedActivationFunction, &fbb)
    return tflite_Pool2DOptions.endPool2DOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.padding.p, fieldName: "padding", required: false, type: tflite_Padding.self)
    try _v.visit(field: VTOFFSET.strideW.p, fieldName: "strideW", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.strideH.p, fieldName: "strideH", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.filterWidth.p, fieldName: "filterWidth", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.filterHeight.p, fieldName: "filterHeight", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.fusedActivationFunction.p, fieldName: "fusedActivationFunction", required: false, type: tflite_ActivationFunctionType.self)
    _v.finish()
  }
}

public struct tflite_DepthwiseConv2DOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_DepthwiseConv2DOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case padding = 4
    case strideW = 6
    case strideH = 8
    case depthMultiplier = 10
    case fusedActivationFunction = 12
    case dilationWFactor = 14
    case dilationHFactor = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var padding: tflite_Padding { let o = _accessor.offset(VTOFFSET.padding.v); return o == 0 ? .same : tflite_Padding(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .same }
  public var strideW: Int32 { let o = _accessor.offset(VTOFFSET.strideW.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var strideH: Int32 { let o = _accessor.offset(VTOFFSET.strideH.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var depthMultiplier: Int32 { let o = _accessor.offset(VTOFFSET.depthMultiplier.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var fusedActivationFunction: tflite_ActivationFunctionType { let o = _accessor.offset(VTOFFSET.fusedActivationFunction.v); return o == 0 ? .none_ : tflite_ActivationFunctionType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public var dilationWFactor: Int32 { let o = _accessor.offset(VTOFFSET.dilationWFactor.v); return o == 0 ? 1 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var dilationHFactor: Int32 { let o = _accessor.offset(VTOFFSET.dilationHFactor.v); return o == 0 ? 1 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startDepthwiseConv2DOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  public static func add(padding: tflite_Padding, _ fbb: inout FlatBufferBuilder) { fbb.add(element: padding.rawValue, def: 0, at: VTOFFSET.padding.p) }
  public static func add(strideW: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: strideW, def: 0, at: VTOFFSET.strideW.p) }
  public static func add(strideH: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: strideH, def: 0, at: VTOFFSET.strideH.p) }
  public static func add(depthMultiplier: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: depthMultiplier, def: 0, at: VTOFFSET.depthMultiplier.p) }
  public static func add(fusedActivationFunction: tflite_ActivationFunctionType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fusedActivationFunction.rawValue, def: 0, at: VTOFFSET.fusedActivationFunction.p) }
  public static func add(dilationWFactor: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dilationWFactor, def: 1, at: VTOFFSET.dilationWFactor.p) }
  public static func add(dilationHFactor: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: dilationHFactor, def: 1, at: VTOFFSET.dilationHFactor.p) }
  public static func endDepthwiseConv2DOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createDepthwiseConv2DOptions(
    _ fbb: inout FlatBufferBuilder,
    padding: tflite_Padding = .same,
    strideW: Int32 = 0,
    strideH: Int32 = 0,
    depthMultiplier: Int32 = 0,
    fusedActivationFunction: tflite_ActivationFunctionType = .none_,
    dilationWFactor: Int32 = 1,
    dilationHFactor: Int32 = 1
  ) -> Offset {
    let __start = tflite_DepthwiseConv2DOptions.startDepthwiseConv2DOptions(&fbb)
    tflite_DepthwiseConv2DOptions.add(padding: padding, &fbb)
    tflite_DepthwiseConv2DOptions.add(strideW: strideW, &fbb)
    tflite_DepthwiseConv2DOptions.add(strideH: strideH, &fbb)
    tflite_DepthwiseConv2DOptions.add(depthMultiplier: depthMultiplier, &fbb)
    tflite_DepthwiseConv2DOptions.add(fusedActivationFunction: fusedActivationFunction, &fbb)
    tflite_DepthwiseConv2DOptions.add(dilationWFactor: dilationWFactor, &fbb)
    tflite_DepthwiseConv2DOptions.add(dilationHFactor: dilationHFactor, &fbb)
    return tflite_DepthwiseConv2DOptions.endDepthwiseConv2DOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.padding.p, fieldName: "padding", required: false, type: tflite_Padding.self)
    try _v.visit(field: VTOFFSET.strideW.p, fieldName: "strideW", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.strideH.p, fieldName: "strideH", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.depthMultiplier.p, fieldName: "depthMultiplier", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.fusedActivationFunction.p, fieldName: "fusedActivationFunction", required: false, type: tflite_ActivationFunctionType.self)
    try _v.visit(field: VTOFFSET.dilationWFactor.p, fieldName: "dilationWFactor", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.dilationHFactor.p, fieldName: "dilationHFactor", required: false, type: Int32.self)
    _v.finish()
  }
}

public struct tflite_ConcatEmbeddingsOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_ConcatEmbeddingsOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case numChannels = 4
    case numColumnsPerChannel = 6
    case embeddingDimPerChannel = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var numChannels: Int32 { let o = _accessor.offset(VTOFFSET.numChannels.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var hasNumColumnsPerChannel: Bool { let o = _accessor.offset(VTOFFSET.numColumnsPerChannel.v); return o == 0 ? false : true }
  public var numColumnsPerChannelCount: Int32 { let o = _accessor.offset(VTOFFSET.numColumnsPerChannel.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func numColumnsPerChannel(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.numColumnsPerChannel.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var numColumnsPerChannel: [Int32] { return _accessor.getVector(at: VTOFFSET.numColumnsPerChannel.v) ?? [] }
  public var hasEmbeddingDimPerChannel: Bool { let o = _accessor.offset(VTOFFSET.embeddingDimPerChannel.v); return o == 0 ? false : true }
  public var embeddingDimPerChannelCount: Int32 { let o = _accessor.offset(VTOFFSET.embeddingDimPerChannel.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func embeddingDimPerChannel(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.embeddingDimPerChannel.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var embeddingDimPerChannel: [Int32] { return _accessor.getVector(at: VTOFFSET.embeddingDimPerChannel.v) ?? [] }
  public static func startConcatEmbeddingsOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(numChannels: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: numChannels, def: 0, at: VTOFFSET.numChannels.p) }
  public static func addVectorOf(numColumnsPerChannel: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: numColumnsPerChannel, at: VTOFFSET.numColumnsPerChannel.p) }
  public static func addVectorOf(embeddingDimPerChannel: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: embeddingDimPerChannel, at: VTOFFSET.embeddingDimPerChannel.p) }
  public static func endConcatEmbeddingsOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createConcatEmbeddingsOptions(
    _ fbb: inout FlatBufferBuilder,
    numChannels: Int32 = 0,
    numColumnsPerChannelVectorOffset numColumnsPerChannel: Offset = Offset(),
    embeddingDimPerChannelVectorOffset embeddingDimPerChannel: Offset = Offset()
  ) -> Offset {
    let __start = tflite_ConcatEmbeddingsOptions.startConcatEmbeddingsOptions(&fbb)
    tflite_ConcatEmbeddingsOptions.add(numChannels: numChannels, &fbb)
    tflite_ConcatEmbeddingsOptions.addVectorOf(numColumnsPerChannel: numColumnsPerChannel, &fbb)
    tflite_ConcatEmbeddingsOptions.addVectorOf(embeddingDimPerChannel: embeddingDimPerChannel, &fbb)
    return tflite_ConcatEmbeddingsOptions.endConcatEmbeddingsOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.numChannels.p, fieldName: "numChannels", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.numColumnsPerChannel.p, fieldName: "numColumnsPerChannel", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(field: VTOFFSET.embeddingDimPerChannel.p, fieldName: "embeddingDimPerChannel", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    _v.finish()
  }
}

public struct tflite_LSHProjectionOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_LSHProjectionOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case type = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var type: tflite_LSHProjectionType { let o = _accessor.offset(VTOFFSET.type.v); return o == 0 ? .unknown : tflite_LSHProjectionType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .unknown }
  public static func startLSHProjectionOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(type: tflite_LSHProjectionType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: type.rawValue, def: 0, at: VTOFFSET.type.p) }
  public static func endLSHProjectionOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createLSHProjectionOptions(
    _ fbb: inout FlatBufferBuilder,
    type: tflite_LSHProjectionType = .unknown
  ) -> Offset {
    let __start = tflite_LSHProjectionOptions.startLSHProjectionOptions(&fbb)
    tflite_LSHProjectionOptions.add(type: type, &fbb)
    return tflite_LSHProjectionOptions.endLSHProjectionOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.type.p, fieldName: "type", required: false, type: tflite_LSHProjectionType.self)
    _v.finish()
  }
}

public struct tflite_SVDFOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_SVDFOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case rank = 4
    case fusedActivationFunction = 6
    case asymmetricQuantizeInputs = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var rank: Int32 { let o = _accessor.offset(VTOFFSET.rank.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var fusedActivationFunction: tflite_ActivationFunctionType { let o = _accessor.offset(VTOFFSET.fusedActivationFunction.v); return o == 0 ? .none_ : tflite_ActivationFunctionType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public var asymmetricQuantizeInputs: Bool { let o = _accessor.offset(VTOFFSET.asymmetricQuantizeInputs.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startSVDFOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(rank: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: rank, def: 0, at: VTOFFSET.rank.p) }
  public static func add(fusedActivationFunction: tflite_ActivationFunctionType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fusedActivationFunction.rawValue, def: 0, at: VTOFFSET.fusedActivationFunction.p) }
  public static func add(asymmetricQuantizeInputs: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: asymmetricQuantizeInputs, def: false,
   at: VTOFFSET.asymmetricQuantizeInputs.p) }
  public static func endSVDFOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSVDFOptions(
    _ fbb: inout FlatBufferBuilder,
    rank: Int32 = 0,
    fusedActivationFunction: tflite_ActivationFunctionType = .none_,
    asymmetricQuantizeInputs: Bool = false
  ) -> Offset {
    let __start = tflite_SVDFOptions.startSVDFOptions(&fbb)
    tflite_SVDFOptions.add(rank: rank, &fbb)
    tflite_SVDFOptions.add(fusedActivationFunction: fusedActivationFunction, &fbb)
    tflite_SVDFOptions.add(asymmetricQuantizeInputs: asymmetricQuantizeInputs, &fbb)
    return tflite_SVDFOptions.endSVDFOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.rank.p, fieldName: "rank", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.fusedActivationFunction.p, fieldName: "fusedActivationFunction", required: false, type: tflite_ActivationFunctionType.self)
    try _v.visit(field: VTOFFSET.asymmetricQuantizeInputs.p, fieldName: "asymmetricQuantizeInputs", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct tflite_RNNOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_RNNOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case fusedActivationFunction = 4
    case asymmetricQuantizeInputs = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var fusedActivationFunction: tflite_ActivationFunctionType { let o = _accessor.offset(VTOFFSET.fusedActivationFunction.v); return o == 0 ? .none_ : tflite_ActivationFunctionType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public var asymmetricQuantizeInputs: Bool { let o = _accessor.offset(VTOFFSET.asymmetricQuantizeInputs.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startRNNOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(fusedActivationFunction: tflite_ActivationFunctionType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fusedActivationFunction.rawValue, def: 0, at: VTOFFSET.fusedActivationFunction.p) }
  public static func add(asymmetricQuantizeInputs: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: asymmetricQuantizeInputs, def: false,
   at: VTOFFSET.asymmetricQuantizeInputs.p) }
  public static func endRNNOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createRNNOptions(
    _ fbb: inout FlatBufferBuilder,
    fusedActivationFunction: tflite_ActivationFunctionType = .none_,
    asymmetricQuantizeInputs: Bool = false
  ) -> Offset {
    let __start = tflite_RNNOptions.startRNNOptions(&fbb)
    tflite_RNNOptions.add(fusedActivationFunction: fusedActivationFunction, &fbb)
    tflite_RNNOptions.add(asymmetricQuantizeInputs: asymmetricQuantizeInputs, &fbb)
    return tflite_RNNOptions.endRNNOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.fusedActivationFunction.p, fieldName: "fusedActivationFunction", required: false, type: tflite_ActivationFunctionType.self)
    try _v.visit(field: VTOFFSET.asymmetricQuantizeInputs.p, fieldName: "asymmetricQuantizeInputs", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct tflite_SequenceRNNOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_SequenceRNNOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case timeMajor = 4
    case fusedActivationFunction = 6
    case asymmetricQuantizeInputs = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var timeMajor: Bool { let o = _accessor.offset(VTOFFSET.timeMajor.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var fusedActivationFunction: tflite_ActivationFunctionType { let o = _accessor.offset(VTOFFSET.fusedActivationFunction.v); return o == 0 ? .none_ : tflite_ActivationFunctionType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public var asymmetricQuantizeInputs: Bool { let o = _accessor.offset(VTOFFSET.asymmetricQuantizeInputs.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startSequenceRNNOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(timeMajor: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: timeMajor, def: false,
   at: VTOFFSET.timeMajor.p) }
  public static func add(fusedActivationFunction: tflite_ActivationFunctionType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fusedActivationFunction.rawValue, def: 0, at: VTOFFSET.fusedActivationFunction.p) }
  public static func add(asymmetricQuantizeInputs: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: asymmetricQuantizeInputs, def: false,
   at: VTOFFSET.asymmetricQuantizeInputs.p) }
  public static func endSequenceRNNOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSequenceRNNOptions(
    _ fbb: inout FlatBufferBuilder,
    timeMajor: Bool = false,
    fusedActivationFunction: tflite_ActivationFunctionType = .none_,
    asymmetricQuantizeInputs: Bool = false
  ) -> Offset {
    let __start = tflite_SequenceRNNOptions.startSequenceRNNOptions(&fbb)
    tflite_SequenceRNNOptions.add(timeMajor: timeMajor, &fbb)
    tflite_SequenceRNNOptions.add(fusedActivationFunction: fusedActivationFunction, &fbb)
    tflite_SequenceRNNOptions.add(asymmetricQuantizeInputs: asymmetricQuantizeInputs, &fbb)
    return tflite_SequenceRNNOptions.endSequenceRNNOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.timeMajor.p, fieldName: "timeMajor", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.fusedActivationFunction.p, fieldName: "fusedActivationFunction", required: false, type: tflite_ActivationFunctionType.self)
    try _v.visit(field: VTOFFSET.asymmetricQuantizeInputs.p, fieldName: "asymmetricQuantizeInputs", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct tflite_BidirectionalSequenceRNNOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_BidirectionalSequenceRNNOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case timeMajor = 4
    case fusedActivationFunction = 6
    case mergeOutputs = 8
    case asymmetricQuantizeInputs = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var timeMajor: Bool { let o = _accessor.offset(VTOFFSET.timeMajor.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var fusedActivationFunction: tflite_ActivationFunctionType { let o = _accessor.offset(VTOFFSET.fusedActivationFunction.v); return o == 0 ? .none_ : tflite_ActivationFunctionType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public var mergeOutputs: Bool { let o = _accessor.offset(VTOFFSET.mergeOutputs.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var asymmetricQuantizeInputs: Bool { let o = _accessor.offset(VTOFFSET.asymmetricQuantizeInputs.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startBidirectionalSequenceRNNOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(timeMajor: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: timeMajor, def: false,
   at: VTOFFSET.timeMajor.p) }
  public static func add(fusedActivationFunction: tflite_ActivationFunctionType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fusedActivationFunction.rawValue, def: 0, at: VTOFFSET.fusedActivationFunction.p) }
  public static func add(mergeOutputs: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: mergeOutputs, def: false,
   at: VTOFFSET.mergeOutputs.p) }
  public static func add(asymmetricQuantizeInputs: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: asymmetricQuantizeInputs, def: false,
   at: VTOFFSET.asymmetricQuantizeInputs.p) }
  public static func endBidirectionalSequenceRNNOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createBidirectionalSequenceRNNOptions(
    _ fbb: inout FlatBufferBuilder,
    timeMajor: Bool = false,
    fusedActivationFunction: tflite_ActivationFunctionType = .none_,
    mergeOutputs: Bool = false,
    asymmetricQuantizeInputs: Bool = false
  ) -> Offset {
    let __start = tflite_BidirectionalSequenceRNNOptions.startBidirectionalSequenceRNNOptions(&fbb)
    tflite_BidirectionalSequenceRNNOptions.add(timeMajor: timeMajor, &fbb)
    tflite_BidirectionalSequenceRNNOptions.add(fusedActivationFunction: fusedActivationFunction, &fbb)
    tflite_BidirectionalSequenceRNNOptions.add(mergeOutputs: mergeOutputs, &fbb)
    tflite_BidirectionalSequenceRNNOptions.add(asymmetricQuantizeInputs: asymmetricQuantizeInputs, &fbb)
    return tflite_BidirectionalSequenceRNNOptions.endBidirectionalSequenceRNNOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.timeMajor.p, fieldName: "timeMajor", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.fusedActivationFunction.p, fieldName: "fusedActivationFunction", required: false, type: tflite_ActivationFunctionType.self)
    try _v.visit(field: VTOFFSET.mergeOutputs.p, fieldName: "mergeOutputs", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.asymmetricQuantizeInputs.p, fieldName: "asymmetricQuantizeInputs", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct tflite_FullyConnectedOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_FullyConnectedOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case fusedActivationFunction = 4
    case weightsFormat = 6
    case keepNumDims = 8
    case asymmetricQuantizeInputs = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var fusedActivationFunction: tflite_ActivationFunctionType { let o = _accessor.offset(VTOFFSET.fusedActivationFunction.v); return o == 0 ? .none_ : tflite_ActivationFunctionType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public var weightsFormat: tflite_FullyConnectedOptionsWeightsFormat { let o = _accessor.offset(VTOFFSET.weightsFormat.v); return o == 0 ? .default_ : tflite_FullyConnectedOptionsWeightsFormat(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .default_ }
  public var keepNumDims: Bool { let o = _accessor.offset(VTOFFSET.keepNumDims.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var asymmetricQuantizeInputs: Bool { let o = _accessor.offset(VTOFFSET.asymmetricQuantizeInputs.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startFullyConnectedOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(fusedActivationFunction: tflite_ActivationFunctionType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fusedActivationFunction.rawValue, def: 0, at: VTOFFSET.fusedActivationFunction.p) }
  public static func add(weightsFormat: tflite_FullyConnectedOptionsWeightsFormat, _ fbb: inout FlatBufferBuilder) { fbb.add(element: weightsFormat.rawValue, def: 0, at: VTOFFSET.weightsFormat.p) }
  public static func add(keepNumDims: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: keepNumDims, def: false,
   at: VTOFFSET.keepNumDims.p) }
  public static func add(asymmetricQuantizeInputs: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: asymmetricQuantizeInputs, def: false,
   at: VTOFFSET.asymmetricQuantizeInputs.p) }
  public static func endFullyConnectedOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFullyConnectedOptions(
    _ fbb: inout FlatBufferBuilder,
    fusedActivationFunction: tflite_ActivationFunctionType = .none_,
    weightsFormat: tflite_FullyConnectedOptionsWeightsFormat = .default_,
    keepNumDims: Bool = false,
    asymmetricQuantizeInputs: Bool = false
  ) -> Offset {
    let __start = tflite_FullyConnectedOptions.startFullyConnectedOptions(&fbb)
    tflite_FullyConnectedOptions.add(fusedActivationFunction: fusedActivationFunction, &fbb)
    tflite_FullyConnectedOptions.add(weightsFormat: weightsFormat, &fbb)
    tflite_FullyConnectedOptions.add(keepNumDims: keepNumDims, &fbb)
    tflite_FullyConnectedOptions.add(asymmetricQuantizeInputs: asymmetricQuantizeInputs, &fbb)
    return tflite_FullyConnectedOptions.endFullyConnectedOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.fusedActivationFunction.p, fieldName: "fusedActivationFunction", required: false, type: tflite_ActivationFunctionType.self)
    try _v.visit(field: VTOFFSET.weightsFormat.p, fieldName: "weightsFormat", required: false, type: tflite_FullyConnectedOptionsWeightsFormat.self)
    try _v.visit(field: VTOFFSET.keepNumDims.p, fieldName: "keepNumDims", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.asymmetricQuantizeInputs.p, fieldName: "asymmetricQuantizeInputs", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct tflite_SoftmaxOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_SoftmaxOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case beta = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var beta: Float32 { let o = _accessor.offset(VTOFFSET.beta.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public static func startSoftmaxOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(beta: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: beta, def: 0.0, at: VTOFFSET.beta.p) }
  public static func endSoftmaxOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSoftmaxOptions(
    _ fbb: inout FlatBufferBuilder,
    beta: Float32 = 0.0
  ) -> Offset {
    let __start = tflite_SoftmaxOptions.startSoftmaxOptions(&fbb)
    tflite_SoftmaxOptions.add(beta: beta, &fbb)
    return tflite_SoftmaxOptions.endSoftmaxOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.beta.p, fieldName: "beta", required: false, type: Float32.self)
    _v.finish()
  }
}

public struct tflite_ConcatenationOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_ConcatenationOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case axis = 4
    case fusedActivationFunction = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var axis: Int32 { let o = _accessor.offset(VTOFFSET.axis.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var fusedActivationFunction: tflite_ActivationFunctionType { let o = _accessor.offset(VTOFFSET.fusedActivationFunction.v); return o == 0 ? .none_ : tflite_ActivationFunctionType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public static func startConcatenationOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(axis: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: axis, def: 0, at: VTOFFSET.axis.p) }
  public static func add(fusedActivationFunction: tflite_ActivationFunctionType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fusedActivationFunction.rawValue, def: 0, at: VTOFFSET.fusedActivationFunction.p) }
  public static func endConcatenationOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createConcatenationOptions(
    _ fbb: inout FlatBufferBuilder,
    axis: Int32 = 0,
    fusedActivationFunction: tflite_ActivationFunctionType = .none_
  ) -> Offset {
    let __start = tflite_ConcatenationOptions.startConcatenationOptions(&fbb)
    tflite_ConcatenationOptions.add(axis: axis, &fbb)
    tflite_ConcatenationOptions.add(fusedActivationFunction: fusedActivationFunction, &fbb)
    return tflite_ConcatenationOptions.endConcatenationOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.axis.p, fieldName: "axis", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.fusedActivationFunction.p, fieldName: "fusedActivationFunction", required: false, type: tflite_ActivationFunctionType.self)
    _v.finish()
  }
}

public struct tflite_AddOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_AddOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case fusedActivationFunction = 4
    case potScaleInt16 = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var fusedActivationFunction: tflite_ActivationFunctionType { let o = _accessor.offset(VTOFFSET.fusedActivationFunction.v); return o == 0 ? .none_ : tflite_ActivationFunctionType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public var potScaleInt16: Bool { let o = _accessor.offset(VTOFFSET.potScaleInt16.v); return o == 0 ? true : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startAddOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(fusedActivationFunction: tflite_ActivationFunctionType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fusedActivationFunction.rawValue, def: 0, at: VTOFFSET.fusedActivationFunction.p) }
  public static func add(potScaleInt16: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: potScaleInt16, def: true,
   at: VTOFFSET.potScaleInt16.p) }
  public static func endAddOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createAddOptions(
    _ fbb: inout FlatBufferBuilder,
    fusedActivationFunction: tflite_ActivationFunctionType = .none_,
    potScaleInt16: Bool = true
  ) -> Offset {
    let __start = tflite_AddOptions.startAddOptions(&fbb)
    tflite_AddOptions.add(fusedActivationFunction: fusedActivationFunction, &fbb)
    tflite_AddOptions.add(potScaleInt16: potScaleInt16, &fbb)
    return tflite_AddOptions.endAddOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.fusedActivationFunction.p, fieldName: "fusedActivationFunction", required: false, type: tflite_ActivationFunctionType.self)
    try _v.visit(field: VTOFFSET.potScaleInt16.p, fieldName: "potScaleInt16", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct tflite_MulOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_MulOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case fusedActivationFunction = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var fusedActivationFunction: tflite_ActivationFunctionType { let o = _accessor.offset(VTOFFSET.fusedActivationFunction.v); return o == 0 ? .none_ : tflite_ActivationFunctionType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public static func startMulOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(fusedActivationFunction: tflite_ActivationFunctionType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fusedActivationFunction.rawValue, def: 0, at: VTOFFSET.fusedActivationFunction.p) }
  public static func endMulOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createMulOptions(
    _ fbb: inout FlatBufferBuilder,
    fusedActivationFunction: tflite_ActivationFunctionType = .none_
  ) -> Offset {
    let __start = tflite_MulOptions.startMulOptions(&fbb)
    tflite_MulOptions.add(fusedActivationFunction: fusedActivationFunction, &fbb)
    return tflite_MulOptions.endMulOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.fusedActivationFunction.p, fieldName: "fusedActivationFunction", required: false, type: tflite_ActivationFunctionType.self)
    _v.finish()
  }
}

public struct tflite_L2NormOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_L2NormOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case fusedActivationFunction = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var fusedActivationFunction: tflite_ActivationFunctionType { let o = _accessor.offset(VTOFFSET.fusedActivationFunction.v); return o == 0 ? .none_ : tflite_ActivationFunctionType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public static func startL2NormOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(fusedActivationFunction: tflite_ActivationFunctionType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fusedActivationFunction.rawValue, def: 0, at: VTOFFSET.fusedActivationFunction.p) }
  public static func endL2NormOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createL2NormOptions(
    _ fbb: inout FlatBufferBuilder,
    fusedActivationFunction: tflite_ActivationFunctionType = .none_
  ) -> Offset {
    let __start = tflite_L2NormOptions.startL2NormOptions(&fbb)
    tflite_L2NormOptions.add(fusedActivationFunction: fusedActivationFunction, &fbb)
    return tflite_L2NormOptions.endL2NormOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.fusedActivationFunction.p, fieldName: "fusedActivationFunction", required: false, type: tflite_ActivationFunctionType.self)
    _v.finish()
  }
}

public struct tflite_LocalResponseNormalizationOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_LocalResponseNormalizationOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case radius = 4
    case bias = 6
    case alpha = 8
    case beta = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var radius: Int32 { let o = _accessor.offset(VTOFFSET.radius.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var bias: Float32 { let o = _accessor.offset(VTOFFSET.bias.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var alpha: Float32 { let o = _accessor.offset(VTOFFSET.alpha.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var beta: Float32 { let o = _accessor.offset(VTOFFSET.beta.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public static func startLocalResponseNormalizationOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(radius: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: radius, def: 0, at: VTOFFSET.radius.p) }
  public static func add(bias: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: bias, def: 0.0, at: VTOFFSET.bias.p) }
  public static func add(alpha: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: alpha, def: 0.0, at: VTOFFSET.alpha.p) }
  public static func add(beta: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: beta, def: 0.0, at: VTOFFSET.beta.p) }
  public static func endLocalResponseNormalizationOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createLocalResponseNormalizationOptions(
    _ fbb: inout FlatBufferBuilder,
    radius: Int32 = 0,
    bias: Float32 = 0.0,
    alpha: Float32 = 0.0,
    beta: Float32 = 0.0
  ) -> Offset {
    let __start = tflite_LocalResponseNormalizationOptions.startLocalResponseNormalizationOptions(&fbb)
    tflite_LocalResponseNormalizationOptions.add(radius: radius, &fbb)
    tflite_LocalResponseNormalizationOptions.add(bias: bias, &fbb)
    tflite_LocalResponseNormalizationOptions.add(alpha: alpha, &fbb)
    tflite_LocalResponseNormalizationOptions.add(beta: beta, &fbb)
    return tflite_LocalResponseNormalizationOptions.endLocalResponseNormalizationOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.radius.p, fieldName: "radius", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.bias.p, fieldName: "bias", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.alpha.p, fieldName: "alpha", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.beta.p, fieldName: "beta", required: false, type: Float32.self)
    _v.finish()
  }
}

public struct tflite_LSTMOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_LSTMOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case fusedActivationFunction = 4
    case cellClip = 6
    case projClip = 8
    case kernelType = 10
    case asymmetricQuantizeInputs = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var fusedActivationFunction: tflite_ActivationFunctionType { let o = _accessor.offset(VTOFFSET.fusedActivationFunction.v); return o == 0 ? .none_ : tflite_ActivationFunctionType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public var cellClip: Float32 { let o = _accessor.offset(VTOFFSET.cellClip.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var projClip: Float32 { let o = _accessor.offset(VTOFFSET.projClip.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var kernelType: tflite_LSTMKernelType { let o = _accessor.offset(VTOFFSET.kernelType.v); return o == 0 ? .full : tflite_LSTMKernelType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .full }
  public var asymmetricQuantizeInputs: Bool { let o = _accessor.offset(VTOFFSET.asymmetricQuantizeInputs.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startLSTMOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(fusedActivationFunction: tflite_ActivationFunctionType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fusedActivationFunction.rawValue, def: 0, at: VTOFFSET.fusedActivationFunction.p) }
  public static func add(cellClip: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: cellClip, def: 0.0, at: VTOFFSET.cellClip.p) }
  public static func add(projClip: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: projClip, def: 0.0, at: VTOFFSET.projClip.p) }
  public static func add(kernelType: tflite_LSTMKernelType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: kernelType.rawValue, def: 0, at: VTOFFSET.kernelType.p) }
  public static func add(asymmetricQuantizeInputs: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: asymmetricQuantizeInputs, def: false,
   at: VTOFFSET.asymmetricQuantizeInputs.p) }
  public static func endLSTMOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createLSTMOptions(
    _ fbb: inout FlatBufferBuilder,
    fusedActivationFunction: tflite_ActivationFunctionType = .none_,
    cellClip: Float32 = 0.0,
    projClip: Float32 = 0.0,
    kernelType: tflite_LSTMKernelType = .full,
    asymmetricQuantizeInputs: Bool = false
  ) -> Offset {
    let __start = tflite_LSTMOptions.startLSTMOptions(&fbb)
    tflite_LSTMOptions.add(fusedActivationFunction: fusedActivationFunction, &fbb)
    tflite_LSTMOptions.add(cellClip: cellClip, &fbb)
    tflite_LSTMOptions.add(projClip: projClip, &fbb)
    tflite_LSTMOptions.add(kernelType: kernelType, &fbb)
    tflite_LSTMOptions.add(asymmetricQuantizeInputs: asymmetricQuantizeInputs, &fbb)
    return tflite_LSTMOptions.endLSTMOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.fusedActivationFunction.p, fieldName: "fusedActivationFunction", required: false, type: tflite_ActivationFunctionType.self)
    try _v.visit(field: VTOFFSET.cellClip.p, fieldName: "cellClip", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.projClip.p, fieldName: "projClip", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.kernelType.p, fieldName: "kernelType", required: false, type: tflite_LSTMKernelType.self)
    try _v.visit(field: VTOFFSET.asymmetricQuantizeInputs.p, fieldName: "asymmetricQuantizeInputs", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct tflite_UnidirectionalSequenceLSTMOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_UnidirectionalSequenceLSTMOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case fusedActivationFunction = 4
    case cellClip = 6
    case projClip = 8
    case timeMajor = 10
    case asymmetricQuantizeInputs = 12
    case diagonalRecurrentTensors = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var fusedActivationFunction: tflite_ActivationFunctionType { let o = _accessor.offset(VTOFFSET.fusedActivationFunction.v); return o == 0 ? .none_ : tflite_ActivationFunctionType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public var cellClip: Float32 { let o = _accessor.offset(VTOFFSET.cellClip.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var projClip: Float32 { let o = _accessor.offset(VTOFFSET.projClip.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var timeMajor: Bool { let o = _accessor.offset(VTOFFSET.timeMajor.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var asymmetricQuantizeInputs: Bool { let o = _accessor.offset(VTOFFSET.asymmetricQuantizeInputs.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var diagonalRecurrentTensors: Bool { let o = _accessor.offset(VTOFFSET.diagonalRecurrentTensors.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startUnidirectionalSequenceLSTMOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(fusedActivationFunction: tflite_ActivationFunctionType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fusedActivationFunction.rawValue, def: 0, at: VTOFFSET.fusedActivationFunction.p) }
  public static func add(cellClip: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: cellClip, def: 0.0, at: VTOFFSET.cellClip.p) }
  public static func add(projClip: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: projClip, def: 0.0, at: VTOFFSET.projClip.p) }
  public static func add(timeMajor: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: timeMajor, def: false,
   at: VTOFFSET.timeMajor.p) }
  public static func add(asymmetricQuantizeInputs: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: asymmetricQuantizeInputs, def: false,
   at: VTOFFSET.asymmetricQuantizeInputs.p) }
  public static func add(diagonalRecurrentTensors: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: diagonalRecurrentTensors, def: false,
   at: VTOFFSET.diagonalRecurrentTensors.p) }
  public static func endUnidirectionalSequenceLSTMOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createUnidirectionalSequenceLSTMOptions(
    _ fbb: inout FlatBufferBuilder,
    fusedActivationFunction: tflite_ActivationFunctionType = .none_,
    cellClip: Float32 = 0.0,
    projClip: Float32 = 0.0,
    timeMajor: Bool = false,
    asymmetricQuantizeInputs: Bool = false,
    diagonalRecurrentTensors: Bool = false
  ) -> Offset {
    let __start = tflite_UnidirectionalSequenceLSTMOptions.startUnidirectionalSequenceLSTMOptions(&fbb)
    tflite_UnidirectionalSequenceLSTMOptions.add(fusedActivationFunction: fusedActivationFunction, &fbb)
    tflite_UnidirectionalSequenceLSTMOptions.add(cellClip: cellClip, &fbb)
    tflite_UnidirectionalSequenceLSTMOptions.add(projClip: projClip, &fbb)
    tflite_UnidirectionalSequenceLSTMOptions.add(timeMajor: timeMajor, &fbb)
    tflite_UnidirectionalSequenceLSTMOptions.add(asymmetricQuantizeInputs: asymmetricQuantizeInputs, &fbb)
    tflite_UnidirectionalSequenceLSTMOptions.add(diagonalRecurrentTensors: diagonalRecurrentTensors, &fbb)
    return tflite_UnidirectionalSequenceLSTMOptions.endUnidirectionalSequenceLSTMOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.fusedActivationFunction.p, fieldName: "fusedActivationFunction", required: false, type: tflite_ActivationFunctionType.self)
    try _v.visit(field: VTOFFSET.cellClip.p, fieldName: "cellClip", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.projClip.p, fieldName: "projClip", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.timeMajor.p, fieldName: "timeMajor", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.asymmetricQuantizeInputs.p, fieldName: "asymmetricQuantizeInputs", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.diagonalRecurrentTensors.p, fieldName: "diagonalRecurrentTensors", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct tflite_BidirectionalSequenceLSTMOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_BidirectionalSequenceLSTMOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case fusedActivationFunction = 4
    case cellClip = 6
    case projClip = 8
    case mergeOutputs = 10
    case timeMajor = 12
    case asymmetricQuantizeInputs = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var fusedActivationFunction: tflite_ActivationFunctionType { let o = _accessor.offset(VTOFFSET.fusedActivationFunction.v); return o == 0 ? .none_ : tflite_ActivationFunctionType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public var cellClip: Float32 { let o = _accessor.offset(VTOFFSET.cellClip.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var projClip: Float32 { let o = _accessor.offset(VTOFFSET.projClip.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var mergeOutputs: Bool { let o = _accessor.offset(VTOFFSET.mergeOutputs.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var timeMajor: Bool { let o = _accessor.offset(VTOFFSET.timeMajor.v); return o == 0 ? true : _accessor.readBuffer(of: Bool.self, at: o) }
  public var asymmetricQuantizeInputs: Bool { let o = _accessor.offset(VTOFFSET.asymmetricQuantizeInputs.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startBidirectionalSequenceLSTMOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(fusedActivationFunction: tflite_ActivationFunctionType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fusedActivationFunction.rawValue, def: 0, at: VTOFFSET.fusedActivationFunction.p) }
  public static func add(cellClip: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: cellClip, def: 0.0, at: VTOFFSET.cellClip.p) }
  public static func add(projClip: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: projClip, def: 0.0, at: VTOFFSET.projClip.p) }
  public static func add(mergeOutputs: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: mergeOutputs, def: false,
   at: VTOFFSET.mergeOutputs.p) }
  public static func add(timeMajor: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: timeMajor, def: true,
   at: VTOFFSET.timeMajor.p) }
  public static func add(asymmetricQuantizeInputs: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: asymmetricQuantizeInputs, def: false,
   at: VTOFFSET.asymmetricQuantizeInputs.p) }
  public static func endBidirectionalSequenceLSTMOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createBidirectionalSequenceLSTMOptions(
    _ fbb: inout FlatBufferBuilder,
    fusedActivationFunction: tflite_ActivationFunctionType = .none_,
    cellClip: Float32 = 0.0,
    projClip: Float32 = 0.0,
    mergeOutputs: Bool = false,
    timeMajor: Bool = true,
    asymmetricQuantizeInputs: Bool = false
  ) -> Offset {
    let __start = tflite_BidirectionalSequenceLSTMOptions.startBidirectionalSequenceLSTMOptions(&fbb)
    tflite_BidirectionalSequenceLSTMOptions.add(fusedActivationFunction: fusedActivationFunction, &fbb)
    tflite_BidirectionalSequenceLSTMOptions.add(cellClip: cellClip, &fbb)
    tflite_BidirectionalSequenceLSTMOptions.add(projClip: projClip, &fbb)
    tflite_BidirectionalSequenceLSTMOptions.add(mergeOutputs: mergeOutputs, &fbb)
    tflite_BidirectionalSequenceLSTMOptions.add(timeMajor: timeMajor, &fbb)
    tflite_BidirectionalSequenceLSTMOptions.add(asymmetricQuantizeInputs: asymmetricQuantizeInputs, &fbb)
    return tflite_BidirectionalSequenceLSTMOptions.endBidirectionalSequenceLSTMOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.fusedActivationFunction.p, fieldName: "fusedActivationFunction", required: false, type: tflite_ActivationFunctionType.self)
    try _v.visit(field: VTOFFSET.cellClip.p, fieldName: "cellClip", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.projClip.p, fieldName: "projClip", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.mergeOutputs.p, fieldName: "mergeOutputs", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.timeMajor.p, fieldName: "timeMajor", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.asymmetricQuantizeInputs.p, fieldName: "asymmetricQuantizeInputs", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct tflite_ResizeBilinearOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_ResizeBilinearOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case alignCorners = 8
    case halfPixelCenters = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var alignCorners: Bool { let o = _accessor.offset(VTOFFSET.alignCorners.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var halfPixelCenters: Bool { let o = _accessor.offset(VTOFFSET.halfPixelCenters.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startResizeBilinearOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(alignCorners: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: alignCorners, def: false,
   at: VTOFFSET.alignCorners.p) }
  public static func add(halfPixelCenters: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: halfPixelCenters, def: false,
   at: VTOFFSET.halfPixelCenters.p) }
  public static func endResizeBilinearOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createResizeBilinearOptions(
    _ fbb: inout FlatBufferBuilder,
    alignCorners: Bool = false,
    halfPixelCenters: Bool = false
  ) -> Offset {
    let __start = tflite_ResizeBilinearOptions.startResizeBilinearOptions(&fbb)
    tflite_ResizeBilinearOptions.add(alignCorners: alignCorners, &fbb)
    tflite_ResizeBilinearOptions.add(halfPixelCenters: halfPixelCenters, &fbb)
    return tflite_ResizeBilinearOptions.endResizeBilinearOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.alignCorners.p, fieldName: "alignCorners", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.halfPixelCenters.p, fieldName: "halfPixelCenters", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct tflite_ResizeNearestNeighborOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_ResizeNearestNeighborOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case alignCorners = 4
    case halfPixelCenters = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var alignCorners: Bool { let o = _accessor.offset(VTOFFSET.alignCorners.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var halfPixelCenters: Bool { let o = _accessor.offset(VTOFFSET.halfPixelCenters.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startResizeNearestNeighborOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(alignCorners: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: alignCorners, def: false,
   at: VTOFFSET.alignCorners.p) }
  public static func add(halfPixelCenters: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: halfPixelCenters, def: false,
   at: VTOFFSET.halfPixelCenters.p) }
  public static func endResizeNearestNeighborOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createResizeNearestNeighborOptions(
    _ fbb: inout FlatBufferBuilder,
    alignCorners: Bool = false,
    halfPixelCenters: Bool = false
  ) -> Offset {
    let __start = tflite_ResizeNearestNeighborOptions.startResizeNearestNeighborOptions(&fbb)
    tflite_ResizeNearestNeighborOptions.add(alignCorners: alignCorners, &fbb)
    tflite_ResizeNearestNeighborOptions.add(halfPixelCenters: halfPixelCenters, &fbb)
    return tflite_ResizeNearestNeighborOptions.endResizeNearestNeighborOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.alignCorners.p, fieldName: "alignCorners", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.halfPixelCenters.p, fieldName: "halfPixelCenters", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct tflite_CallOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_CallOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case subgraph = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var subgraph: UInt32 { let o = _accessor.offset(VTOFFSET.subgraph.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public static func startCallOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(subgraph: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: subgraph, def: 0, at: VTOFFSET.subgraph.p) }
  public static func endCallOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCallOptions(
    _ fbb: inout FlatBufferBuilder,
    subgraph: UInt32 = 0
  ) -> Offset {
    let __start = tflite_CallOptions.startCallOptions(&fbb)
    tflite_CallOptions.add(subgraph: subgraph, &fbb)
    return tflite_CallOptions.endCallOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.subgraph.p, fieldName: "subgraph", required: false, type: UInt32.self)
    _v.finish()
  }
}

public struct tflite_PadOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_PadOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startPadOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endPadOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_PadV2Options: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_PadV2Options.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startPadV2Options(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endPadV2Options(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_ReshapeOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_ReshapeOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case newShape = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasNewShape: Bool { let o = _accessor.offset(VTOFFSET.newShape.v); return o == 0 ? false : true }
  public var newShapeCount: Int32 { let o = _accessor.offset(VTOFFSET.newShape.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func newShape(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.newShape.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var newShape: [Int32] { return _accessor.getVector(at: VTOFFSET.newShape.v) ?? [] }
  public static func startReshapeOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(newShape: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: newShape, at: VTOFFSET.newShape.p) }
  public static func endReshapeOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createReshapeOptions(
    _ fbb: inout FlatBufferBuilder,
    newShapeVectorOffset newShape: Offset = Offset()
  ) -> Offset {
    let __start = tflite_ReshapeOptions.startReshapeOptions(&fbb)
    tflite_ReshapeOptions.addVectorOf(newShape: newShape, &fbb)
    return tflite_ReshapeOptions.endReshapeOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.newShape.p, fieldName: "newShape", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    _v.finish()
  }
}

public struct tflite_SpaceToBatchNDOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_SpaceToBatchNDOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startSpaceToBatchNDOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endSpaceToBatchNDOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_BatchToSpaceNDOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_BatchToSpaceNDOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startBatchToSpaceNDOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endBatchToSpaceNDOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_SkipGramOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_SkipGramOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case ngramSize = 4
    case maxSkipSize = 6
    case includeAllNgrams = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var ngramSize: Int32 { let o = _accessor.offset(VTOFFSET.ngramSize.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var maxSkipSize: Int32 { let o = _accessor.offset(VTOFFSET.maxSkipSize.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var includeAllNgrams: Bool { let o = _accessor.offset(VTOFFSET.includeAllNgrams.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startSkipGramOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(ngramSize: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ngramSize, def: 0, at: VTOFFSET.ngramSize.p) }
  public static func add(maxSkipSize: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: maxSkipSize, def: 0, at: VTOFFSET.maxSkipSize.p) }
  public static func add(includeAllNgrams: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: includeAllNgrams, def: false,
   at: VTOFFSET.includeAllNgrams.p) }
  public static func endSkipGramOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSkipGramOptions(
    _ fbb: inout FlatBufferBuilder,
    ngramSize: Int32 = 0,
    maxSkipSize: Int32 = 0,
    includeAllNgrams: Bool = false
  ) -> Offset {
    let __start = tflite_SkipGramOptions.startSkipGramOptions(&fbb)
    tflite_SkipGramOptions.add(ngramSize: ngramSize, &fbb)
    tflite_SkipGramOptions.add(maxSkipSize: maxSkipSize, &fbb)
    tflite_SkipGramOptions.add(includeAllNgrams: includeAllNgrams, &fbb)
    return tflite_SkipGramOptions.endSkipGramOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.ngramSize.p, fieldName: "ngramSize", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.maxSkipSize.p, fieldName: "maxSkipSize", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.includeAllNgrams.p, fieldName: "includeAllNgrams", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct tflite_SpaceToDepthOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_SpaceToDepthOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case blockSize = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var blockSize: Int32 { let o = _accessor.offset(VTOFFSET.blockSize.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startSpaceToDepthOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(blockSize: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: blockSize, def: 0, at: VTOFFSET.blockSize.p) }
  public static func endSpaceToDepthOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSpaceToDepthOptions(
    _ fbb: inout FlatBufferBuilder,
    blockSize: Int32 = 0
  ) -> Offset {
    let __start = tflite_SpaceToDepthOptions.startSpaceToDepthOptions(&fbb)
    tflite_SpaceToDepthOptions.add(blockSize: blockSize, &fbb)
    return tflite_SpaceToDepthOptions.endSpaceToDepthOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.blockSize.p, fieldName: "blockSize", required: false, type: Int32.self)
    _v.finish()
  }
}

public struct tflite_DepthToSpaceOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_DepthToSpaceOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case blockSize = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var blockSize: Int32 { let o = _accessor.offset(VTOFFSET.blockSize.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startDepthToSpaceOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(blockSize: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: blockSize, def: 0, at: VTOFFSET.blockSize.p) }
  public static func endDepthToSpaceOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createDepthToSpaceOptions(
    _ fbb: inout FlatBufferBuilder,
    blockSize: Int32 = 0
  ) -> Offset {
    let __start = tflite_DepthToSpaceOptions.startDepthToSpaceOptions(&fbb)
    tflite_DepthToSpaceOptions.add(blockSize: blockSize, &fbb)
    return tflite_DepthToSpaceOptions.endDepthToSpaceOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.blockSize.p, fieldName: "blockSize", required: false, type: Int32.self)
    _v.finish()
  }
}

public struct tflite_SubOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_SubOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case fusedActivationFunction = 4
    case potScaleInt16 = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var fusedActivationFunction: tflite_ActivationFunctionType { let o = _accessor.offset(VTOFFSET.fusedActivationFunction.v); return o == 0 ? .none_ : tflite_ActivationFunctionType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public var potScaleInt16: Bool { let o = _accessor.offset(VTOFFSET.potScaleInt16.v); return o == 0 ? true : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startSubOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(fusedActivationFunction: tflite_ActivationFunctionType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fusedActivationFunction.rawValue, def: 0, at: VTOFFSET.fusedActivationFunction.p) }
  public static func add(potScaleInt16: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: potScaleInt16, def: true,
   at: VTOFFSET.potScaleInt16.p) }
  public static func endSubOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSubOptions(
    _ fbb: inout FlatBufferBuilder,
    fusedActivationFunction: tflite_ActivationFunctionType = .none_,
    potScaleInt16: Bool = true
  ) -> Offset {
    let __start = tflite_SubOptions.startSubOptions(&fbb)
    tflite_SubOptions.add(fusedActivationFunction: fusedActivationFunction, &fbb)
    tflite_SubOptions.add(potScaleInt16: potScaleInt16, &fbb)
    return tflite_SubOptions.endSubOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.fusedActivationFunction.p, fieldName: "fusedActivationFunction", required: false, type: tflite_ActivationFunctionType.self)
    try _v.visit(field: VTOFFSET.potScaleInt16.p, fieldName: "potScaleInt16", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct tflite_DivOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_DivOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case fusedActivationFunction = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var fusedActivationFunction: tflite_ActivationFunctionType { let o = _accessor.offset(VTOFFSET.fusedActivationFunction.v); return o == 0 ? .none_ : tflite_ActivationFunctionType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public static func startDivOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(fusedActivationFunction: tflite_ActivationFunctionType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fusedActivationFunction.rawValue, def: 0, at: VTOFFSET.fusedActivationFunction.p) }
  public static func endDivOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createDivOptions(
    _ fbb: inout FlatBufferBuilder,
    fusedActivationFunction: tflite_ActivationFunctionType = .none_
  ) -> Offset {
    let __start = tflite_DivOptions.startDivOptions(&fbb)
    tflite_DivOptions.add(fusedActivationFunction: fusedActivationFunction, &fbb)
    return tflite_DivOptions.endDivOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.fusedActivationFunction.p, fieldName: "fusedActivationFunction", required: false, type: tflite_ActivationFunctionType.self)
    _v.finish()
  }
}

public struct tflite_TopKV2Options: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_TopKV2Options.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startTopKV2Options(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endTopKV2Options(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_EmbeddingLookupSparseOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_EmbeddingLookupSparseOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case combiner = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var combiner: tflite_CombinerType { let o = _accessor.offset(VTOFFSET.combiner.v); return o == 0 ? .sum : tflite_CombinerType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .sum }
  public static func startEmbeddingLookupSparseOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(combiner: tflite_CombinerType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: combiner.rawValue, def: 0, at: VTOFFSET.combiner.p) }
  public static func endEmbeddingLookupSparseOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createEmbeddingLookupSparseOptions(
    _ fbb: inout FlatBufferBuilder,
    combiner: tflite_CombinerType = .sum
  ) -> Offset {
    let __start = tflite_EmbeddingLookupSparseOptions.startEmbeddingLookupSparseOptions(&fbb)
    tflite_EmbeddingLookupSparseOptions.add(combiner: combiner, &fbb)
    return tflite_EmbeddingLookupSparseOptions.endEmbeddingLookupSparseOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.combiner.p, fieldName: "combiner", required: false, type: tflite_CombinerType.self)
    _v.finish()
  }
}

public struct tflite_GatherOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_GatherOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case axis = 4
    case batchDims = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var axis: Int32 { let o = _accessor.offset(VTOFFSET.axis.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var batchDims: Int32 { let o = _accessor.offset(VTOFFSET.batchDims.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startGatherOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(axis: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: axis, def: 0, at: VTOFFSET.axis.p) }
  public static func add(batchDims: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: batchDims, def: 0, at: VTOFFSET.batchDims.p) }
  public static func endGatherOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createGatherOptions(
    _ fbb: inout FlatBufferBuilder,
    axis: Int32 = 0,
    batchDims: Int32 = 0
  ) -> Offset {
    let __start = tflite_GatherOptions.startGatherOptions(&fbb)
    tflite_GatherOptions.add(axis: axis, &fbb)
    tflite_GatherOptions.add(batchDims: batchDims, &fbb)
    return tflite_GatherOptions.endGatherOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.axis.p, fieldName: "axis", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.batchDims.p, fieldName: "batchDims", required: false, type: Int32.self)
    _v.finish()
  }
}

public struct tflite_TransposeOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_TransposeOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startTransposeOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endTransposeOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_ExpOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_ExpOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startExpOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endExpOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_CosOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_CosOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startCosOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endCosOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_ReducerOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_ReducerOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case keepDims = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var keepDims: Bool { let o = _accessor.offset(VTOFFSET.keepDims.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startReducerOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(keepDims: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: keepDims, def: false,
   at: VTOFFSET.keepDims.p) }
  public static func endReducerOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createReducerOptions(
    _ fbb: inout FlatBufferBuilder,
    keepDims: Bool = false
  ) -> Offset {
    let __start = tflite_ReducerOptions.startReducerOptions(&fbb)
    tflite_ReducerOptions.add(keepDims: keepDims, &fbb)
    return tflite_ReducerOptions.endReducerOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.keepDims.p, fieldName: "keepDims", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct tflite_SqueezeOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_SqueezeOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case squeezeDims = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasSqueezeDims: Bool { let o = _accessor.offset(VTOFFSET.squeezeDims.v); return o == 0 ? false : true }
  public var squeezeDimsCount: Int32 { let o = _accessor.offset(VTOFFSET.squeezeDims.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func squeezeDims(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.squeezeDims.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var squeezeDims: [Int32] { return _accessor.getVector(at: VTOFFSET.squeezeDims.v) ?? [] }
  public static func startSqueezeOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(squeezeDims: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: squeezeDims, at: VTOFFSET.squeezeDims.p) }
  public static func endSqueezeOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSqueezeOptions(
    _ fbb: inout FlatBufferBuilder,
    squeezeDimsVectorOffset squeezeDims: Offset = Offset()
  ) -> Offset {
    let __start = tflite_SqueezeOptions.startSqueezeOptions(&fbb)
    tflite_SqueezeOptions.addVectorOf(squeezeDims: squeezeDims, &fbb)
    return tflite_SqueezeOptions.endSqueezeOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.squeezeDims.p, fieldName: "squeezeDims", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    _v.finish()
  }
}

public struct tflite_SplitOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_SplitOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case numSplits = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var numSplits: Int32 { let o = _accessor.offset(VTOFFSET.numSplits.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startSplitOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(numSplits: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: numSplits, def: 0, at: VTOFFSET.numSplits.p) }
  public static func endSplitOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSplitOptions(
    _ fbb: inout FlatBufferBuilder,
    numSplits: Int32 = 0
  ) -> Offset {
    let __start = tflite_SplitOptions.startSplitOptions(&fbb)
    tflite_SplitOptions.add(numSplits: numSplits, &fbb)
    return tflite_SplitOptions.endSplitOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.numSplits.p, fieldName: "numSplits", required: false, type: Int32.self)
    _v.finish()
  }
}

public struct tflite_SplitVOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_SplitVOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case numSplits = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var numSplits: Int32 { let o = _accessor.offset(VTOFFSET.numSplits.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startSplitVOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(numSplits: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: numSplits, def: 0, at: VTOFFSET.numSplits.p) }
  public static func endSplitVOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSplitVOptions(
    _ fbb: inout FlatBufferBuilder,
    numSplits: Int32 = 0
  ) -> Offset {
    let __start = tflite_SplitVOptions.startSplitVOptions(&fbb)
    tflite_SplitVOptions.add(numSplits: numSplits, &fbb)
    return tflite_SplitVOptions.endSplitVOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.numSplits.p, fieldName: "numSplits", required: false, type: Int32.self)
    _v.finish()
  }
}

public struct tflite_StridedSliceOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_StridedSliceOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case beginMask = 4
    case endMask = 6
    case ellipsisMask = 8
    case newAxisMask = 10
    case shrinkAxisMask = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var beginMask: Int32 { let o = _accessor.offset(VTOFFSET.beginMask.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var endMask: Int32 { let o = _accessor.offset(VTOFFSET.endMask.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var ellipsisMask: Int32 { let o = _accessor.offset(VTOFFSET.ellipsisMask.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var newAxisMask: Int32 { let o = _accessor.offset(VTOFFSET.newAxisMask.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var shrinkAxisMask: Int32 { let o = _accessor.offset(VTOFFSET.shrinkAxisMask.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startStridedSliceOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(beginMask: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: beginMask, def: 0, at: VTOFFSET.beginMask.p) }
  public static func add(endMask: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: endMask, def: 0, at: VTOFFSET.endMask.p) }
  public static func add(ellipsisMask: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ellipsisMask, def: 0, at: VTOFFSET.ellipsisMask.p) }
  public static func add(newAxisMask: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: newAxisMask, def: 0, at: VTOFFSET.newAxisMask.p) }
  public static func add(shrinkAxisMask: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: shrinkAxisMask, def: 0, at: VTOFFSET.shrinkAxisMask.p) }
  public static func endStridedSliceOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createStridedSliceOptions(
    _ fbb: inout FlatBufferBuilder,
    beginMask: Int32 = 0,
    endMask: Int32 = 0,
    ellipsisMask: Int32 = 0,
    newAxisMask: Int32 = 0,
    shrinkAxisMask: Int32 = 0
  ) -> Offset {
    let __start = tflite_StridedSliceOptions.startStridedSliceOptions(&fbb)
    tflite_StridedSliceOptions.add(beginMask: beginMask, &fbb)
    tflite_StridedSliceOptions.add(endMask: endMask, &fbb)
    tflite_StridedSliceOptions.add(ellipsisMask: ellipsisMask, &fbb)
    tflite_StridedSliceOptions.add(newAxisMask: newAxisMask, &fbb)
    tflite_StridedSliceOptions.add(shrinkAxisMask: shrinkAxisMask, &fbb)
    return tflite_StridedSliceOptions.endStridedSliceOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.beginMask.p, fieldName: "beginMask", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.endMask.p, fieldName: "endMask", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.ellipsisMask.p, fieldName: "ellipsisMask", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.newAxisMask.p, fieldName: "newAxisMask", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.shrinkAxisMask.p, fieldName: "shrinkAxisMask", required: false, type: Int32.self)
    _v.finish()
  }
}

public struct tflite_LogSoftmaxOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_LogSoftmaxOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startLogSoftmaxOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endLogSoftmaxOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_CastOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_CastOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case inDataType = 4
    case outDataType = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var inDataType: tflite_TensorType { let o = _accessor.offset(VTOFFSET.inDataType.v); return o == 0 ? .float32 : tflite_TensorType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .float32 }
  public var outDataType: tflite_TensorType { let o = _accessor.offset(VTOFFSET.outDataType.v); return o == 0 ? .float32 : tflite_TensorType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .float32 }
  public static func startCastOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(inDataType: tflite_TensorType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: inDataType.rawValue, def: 0, at: VTOFFSET.inDataType.p) }
  public static func add(outDataType: tflite_TensorType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: outDataType.rawValue, def: 0, at: VTOFFSET.outDataType.p) }
  public static func endCastOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCastOptions(
    _ fbb: inout FlatBufferBuilder,
    inDataType: tflite_TensorType = .float32,
    outDataType: tflite_TensorType = .float32
  ) -> Offset {
    let __start = tflite_CastOptions.startCastOptions(&fbb)
    tflite_CastOptions.add(inDataType: inDataType, &fbb)
    tflite_CastOptions.add(outDataType: outDataType, &fbb)
    return tflite_CastOptions.endCastOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.inDataType.p, fieldName: "inDataType", required: false, type: tflite_TensorType.self)
    try _v.visit(field: VTOFFSET.outDataType.p, fieldName: "outDataType", required: false, type: tflite_TensorType.self)
    _v.finish()
  }
}

public struct tflite_DequantizeOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_DequantizeOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startDequantizeOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endDequantizeOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_MaximumMinimumOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_MaximumMinimumOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startMaximumMinimumOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endMaximumMinimumOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_TileOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_TileOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startTileOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endTileOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_ArgMaxOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_ArgMaxOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case outputType = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var outputType: tflite_TensorType { let o = _accessor.offset(VTOFFSET.outputType.v); return o == 0 ? .float32 : tflite_TensorType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .float32 }
  public static func startArgMaxOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(outputType: tflite_TensorType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: outputType.rawValue, def: 0, at: VTOFFSET.outputType.p) }
  public static func endArgMaxOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createArgMaxOptions(
    _ fbb: inout FlatBufferBuilder,
    outputType: tflite_TensorType = .float32
  ) -> Offset {
    let __start = tflite_ArgMaxOptions.startArgMaxOptions(&fbb)
    tflite_ArgMaxOptions.add(outputType: outputType, &fbb)
    return tflite_ArgMaxOptions.endArgMaxOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.outputType.p, fieldName: "outputType", required: false, type: tflite_TensorType.self)
    _v.finish()
  }
}

public struct tflite_ArgMinOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_ArgMinOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case outputType = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var outputType: tflite_TensorType { let o = _accessor.offset(VTOFFSET.outputType.v); return o == 0 ? .float32 : tflite_TensorType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .float32 }
  public static func startArgMinOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(outputType: tflite_TensorType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: outputType.rawValue, def: 0, at: VTOFFSET.outputType.p) }
  public static func endArgMinOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createArgMinOptions(
    _ fbb: inout FlatBufferBuilder,
    outputType: tflite_TensorType = .float32
  ) -> Offset {
    let __start = tflite_ArgMinOptions.startArgMinOptions(&fbb)
    tflite_ArgMinOptions.add(outputType: outputType, &fbb)
    return tflite_ArgMinOptions.endArgMinOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.outputType.p, fieldName: "outputType", required: false, type: tflite_TensorType.self)
    _v.finish()
  }
}

public struct tflite_GreaterOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_GreaterOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startGreaterOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endGreaterOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_GreaterEqualOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_GreaterEqualOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startGreaterEqualOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endGreaterEqualOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_LessOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_LessOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startLessOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endLessOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_LessEqualOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_LessEqualOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startLessEqualOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endLessEqualOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_NegOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_NegOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startNegOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endNegOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_SelectOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_SelectOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startSelectOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endSelectOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_SliceOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_SliceOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startSliceOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endSliceOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_TransposeConvOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_TransposeConvOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case padding = 4
    case strideW = 6
    case strideH = 8
    case fusedActivationFunction = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var padding: tflite_Padding { let o = _accessor.offset(VTOFFSET.padding.v); return o == 0 ? .same : tflite_Padding(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .same }
  public var strideW: Int32 { let o = _accessor.offset(VTOFFSET.strideW.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var strideH: Int32 { let o = _accessor.offset(VTOFFSET.strideH.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var fusedActivationFunction: tflite_ActivationFunctionType { let o = _accessor.offset(VTOFFSET.fusedActivationFunction.v); return o == 0 ? .none_ : tflite_ActivationFunctionType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public static func startTransposeConvOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(padding: tflite_Padding, _ fbb: inout FlatBufferBuilder) { fbb.add(element: padding.rawValue, def: 0, at: VTOFFSET.padding.p) }
  public static func add(strideW: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: strideW, def: 0, at: VTOFFSET.strideW.p) }
  public static func add(strideH: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: strideH, def: 0, at: VTOFFSET.strideH.p) }
  public static func add(fusedActivationFunction: tflite_ActivationFunctionType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: fusedActivationFunction.rawValue, def: 0, at: VTOFFSET.fusedActivationFunction.p) }
  public static func endTransposeConvOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createTransposeConvOptions(
    _ fbb: inout FlatBufferBuilder,
    padding: tflite_Padding = .same,
    strideW: Int32 = 0,
    strideH: Int32 = 0,
    fusedActivationFunction: tflite_ActivationFunctionType = .none_
  ) -> Offset {
    let __start = tflite_TransposeConvOptions.startTransposeConvOptions(&fbb)
    tflite_TransposeConvOptions.add(padding: padding, &fbb)
    tflite_TransposeConvOptions.add(strideW: strideW, &fbb)
    tflite_TransposeConvOptions.add(strideH: strideH, &fbb)
    tflite_TransposeConvOptions.add(fusedActivationFunction: fusedActivationFunction, &fbb)
    return tflite_TransposeConvOptions.endTransposeConvOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.padding.p, fieldName: "padding", required: false, type: tflite_Padding.self)
    try _v.visit(field: VTOFFSET.strideW.p, fieldName: "strideW", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.strideH.p, fieldName: "strideH", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.fusedActivationFunction.p, fieldName: "fusedActivationFunction", required: false, type: tflite_ActivationFunctionType.self)
    _v.finish()
  }
}

public struct tflite_ExpandDimsOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_ExpandDimsOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startExpandDimsOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endExpandDimsOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_SparseToDenseOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_SparseToDenseOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case validateIndices = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var validateIndices: Bool { let o = _accessor.offset(VTOFFSET.validateIndices.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startSparseToDenseOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(validateIndices: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: validateIndices, def: false,
   at: VTOFFSET.validateIndices.p) }
  public static func endSparseToDenseOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSparseToDenseOptions(
    _ fbb: inout FlatBufferBuilder,
    validateIndices: Bool = false
  ) -> Offset {
    let __start = tflite_SparseToDenseOptions.startSparseToDenseOptions(&fbb)
    tflite_SparseToDenseOptions.add(validateIndices: validateIndices, &fbb)
    return tflite_SparseToDenseOptions.endSparseToDenseOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.validateIndices.p, fieldName: "validateIndices", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct tflite_EqualOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_EqualOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startEqualOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endEqualOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_NotEqualOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_NotEqualOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startNotEqualOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endNotEqualOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_ShapeOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_ShapeOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case outType = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var outType: tflite_TensorType { let o = _accessor.offset(VTOFFSET.outType.v); return o == 0 ? .float32 : tflite_TensorType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .float32 }
  public static func startShapeOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(outType: tflite_TensorType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: outType.rawValue, def: 0, at: VTOFFSET.outType.p) }
  public static func endShapeOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createShapeOptions(
    _ fbb: inout FlatBufferBuilder,
    outType: tflite_TensorType = .float32
  ) -> Offset {
    let __start = tflite_ShapeOptions.startShapeOptions(&fbb)
    tflite_ShapeOptions.add(outType: outType, &fbb)
    return tflite_ShapeOptions.endShapeOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.outType.p, fieldName: "outType", required: false, type: tflite_TensorType.self)
    _v.finish()
  }
}

public struct tflite_RankOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_RankOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startRankOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endRankOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_PowOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_PowOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startPowOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endPowOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_FakeQuantOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_FakeQuantOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case min = 4
    case max = 6
    case numBits = 8
    case narrowRange = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var min: Float32 { let o = _accessor.offset(VTOFFSET.min.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var max: Float32 { let o = _accessor.offset(VTOFFSET.max.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var numBits: Int32 { let o = _accessor.offset(VTOFFSET.numBits.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var narrowRange: Bool { let o = _accessor.offset(VTOFFSET.narrowRange.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startFakeQuantOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(min: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: min, def: 0.0, at: VTOFFSET.min.p) }
  public static func add(max: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: max, def: 0.0, at: VTOFFSET.max.p) }
  public static func add(numBits: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: numBits, def: 0, at: VTOFFSET.numBits.p) }
  public static func add(narrowRange: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: narrowRange, def: false,
   at: VTOFFSET.narrowRange.p) }
  public static func endFakeQuantOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFakeQuantOptions(
    _ fbb: inout FlatBufferBuilder,
    min: Float32 = 0.0,
    max: Float32 = 0.0,
    numBits: Int32 = 0,
    narrowRange: Bool = false
  ) -> Offset {
    let __start = tflite_FakeQuantOptions.startFakeQuantOptions(&fbb)
    tflite_FakeQuantOptions.add(min: min, &fbb)
    tflite_FakeQuantOptions.add(max: max, &fbb)
    tflite_FakeQuantOptions.add(numBits: numBits, &fbb)
    tflite_FakeQuantOptions.add(narrowRange: narrowRange, &fbb)
    return tflite_FakeQuantOptions.endFakeQuantOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.min.p, fieldName: "min", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.max.p, fieldName: "max", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.numBits.p, fieldName: "numBits", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.narrowRange.p, fieldName: "narrowRange", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct tflite_PackOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_PackOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case valuesCount = 4
    case axis = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var valuesCount: Int32 { let o = _accessor.offset(VTOFFSET.valuesCount.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var axis: Int32 { let o = _accessor.offset(VTOFFSET.axis.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startPackOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(valuesCount: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: valuesCount, def: 0, at: VTOFFSET.valuesCount.p) }
  public static func add(axis: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: axis, def: 0, at: VTOFFSET.axis.p) }
  public static func endPackOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPackOptions(
    _ fbb: inout FlatBufferBuilder,
    valuesCount: Int32 = 0,
    axis: Int32 = 0
  ) -> Offset {
    let __start = tflite_PackOptions.startPackOptions(&fbb)
    tflite_PackOptions.add(valuesCount: valuesCount, &fbb)
    tflite_PackOptions.add(axis: axis, &fbb)
    return tflite_PackOptions.endPackOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.valuesCount.p, fieldName: "valuesCount", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.axis.p, fieldName: "axis", required: false, type: Int32.self)
    _v.finish()
  }
}

public struct tflite_LogicalOrOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_LogicalOrOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startLogicalOrOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endLogicalOrOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_OneHotOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_OneHotOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case axis = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var axis: Int32 { let o = _accessor.offset(VTOFFSET.axis.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startOneHotOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(axis: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: axis, def: 0, at: VTOFFSET.axis.p) }
  public static func endOneHotOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createOneHotOptions(
    _ fbb: inout FlatBufferBuilder,
    axis: Int32 = 0
  ) -> Offset {
    let __start = tflite_OneHotOptions.startOneHotOptions(&fbb)
    tflite_OneHotOptions.add(axis: axis, &fbb)
    return tflite_OneHotOptions.endOneHotOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.axis.p, fieldName: "axis", required: false, type: Int32.self)
    _v.finish()
  }
}

public struct tflite_AbsOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_AbsOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startAbsOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endAbsOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_HardSwishOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_HardSwishOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startHardSwishOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endHardSwishOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_LogicalAndOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_LogicalAndOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startLogicalAndOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endLogicalAndOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_LogicalNotOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_LogicalNotOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startLogicalNotOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endLogicalNotOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_UnpackOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_UnpackOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case num = 4
    case axis = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var num: Int32 { let o = _accessor.offset(VTOFFSET.num.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var axis: Int32 { let o = _accessor.offset(VTOFFSET.axis.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startUnpackOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(num: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: num, def: 0, at: VTOFFSET.num.p) }
  public static func add(axis: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: axis, def: 0, at: VTOFFSET.axis.p) }
  public static func endUnpackOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createUnpackOptions(
    _ fbb: inout FlatBufferBuilder,
    num: Int32 = 0,
    axis: Int32 = 0
  ) -> Offset {
    let __start = tflite_UnpackOptions.startUnpackOptions(&fbb)
    tflite_UnpackOptions.add(num: num, &fbb)
    tflite_UnpackOptions.add(axis: axis, &fbb)
    return tflite_UnpackOptions.endUnpackOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.num.p, fieldName: "num", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.axis.p, fieldName: "axis", required: false, type: Int32.self)
    _v.finish()
  }
}

public struct tflite_FloorDivOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_FloorDivOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startFloorDivOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endFloorDivOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_SquareOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_SquareOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startSquareOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endSquareOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_ZerosLikeOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_ZerosLikeOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startZerosLikeOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endZerosLikeOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_FillOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_FillOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startFillOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endFillOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_FloorModOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_FloorModOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startFloorModOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endFloorModOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_RangeOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_RangeOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startRangeOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endRangeOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_LeakyReluOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_LeakyReluOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case alpha = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var alpha: Float32 { let o = _accessor.offset(VTOFFSET.alpha.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public static func startLeakyReluOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(alpha: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: alpha, def: 0.0, at: VTOFFSET.alpha.p) }
  public static func endLeakyReluOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createLeakyReluOptions(
    _ fbb: inout FlatBufferBuilder,
    alpha: Float32 = 0.0
  ) -> Offset {
    let __start = tflite_LeakyReluOptions.startLeakyReluOptions(&fbb)
    tflite_LeakyReluOptions.add(alpha: alpha, &fbb)
    return tflite_LeakyReluOptions.endLeakyReluOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.alpha.p, fieldName: "alpha", required: false, type: Float32.self)
    _v.finish()
  }
}

public struct tflite_SquaredDifferenceOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_SquaredDifferenceOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startSquaredDifferenceOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endSquaredDifferenceOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_MirrorPadOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_MirrorPadOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case mode = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var mode: tflite_MirrorPadMode { let o = _accessor.offset(VTOFFSET.mode.v); return o == 0 ? .reflect : tflite_MirrorPadMode(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .reflect }
  public static func startMirrorPadOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(mode: tflite_MirrorPadMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: mode.rawValue, def: 0, at: VTOFFSET.mode.p) }
  public static func endMirrorPadOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createMirrorPadOptions(
    _ fbb: inout FlatBufferBuilder,
    mode: tflite_MirrorPadMode = .reflect
  ) -> Offset {
    let __start = tflite_MirrorPadOptions.startMirrorPadOptions(&fbb)
    tflite_MirrorPadOptions.add(mode: mode, &fbb)
    return tflite_MirrorPadOptions.endMirrorPadOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.mode.p, fieldName: "mode", required: false, type: tflite_MirrorPadMode.self)
    _v.finish()
  }
}

public struct tflite_UniqueOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_UniqueOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case idxOutType = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var idxOutType: tflite_TensorType { let o = _accessor.offset(VTOFFSET.idxOutType.v); return o == 0 ? .int32 : tflite_TensorType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .int32 }
  public static func startUniqueOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(idxOutType: tflite_TensorType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: idxOutType.rawValue, def: 2, at: VTOFFSET.idxOutType.p) }
  public static func endUniqueOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createUniqueOptions(
    _ fbb: inout FlatBufferBuilder,
    idxOutType: tflite_TensorType = .int32
  ) -> Offset {
    let __start = tflite_UniqueOptions.startUniqueOptions(&fbb)
    tflite_UniqueOptions.add(idxOutType: idxOutType, &fbb)
    return tflite_UniqueOptions.endUniqueOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.idxOutType.p, fieldName: "idxOutType", required: false, type: tflite_TensorType.self)
    _v.finish()
  }
}

public struct tflite_ReverseV2Options: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_ReverseV2Options.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startReverseV2Options(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endReverseV2Options(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_AddNOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_AddNOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startAddNOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endAddNOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_GatherNdOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_GatherNdOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startGatherNdOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endGatherNdOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_WhereOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_WhereOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startWhereOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endWhereOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_ReverseSequenceOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_ReverseSequenceOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case seqDim = 4
    case batchDim = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var seqDim: Int32 { let o = _accessor.offset(VTOFFSET.seqDim.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var batchDim: Int32 { let o = _accessor.offset(VTOFFSET.batchDim.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startReverseSequenceOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(seqDim: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: seqDim, def: 0, at: VTOFFSET.seqDim.p) }
  public static func add(batchDim: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: batchDim, def: 0, at: VTOFFSET.batchDim.p) }
  public static func endReverseSequenceOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createReverseSequenceOptions(
    _ fbb: inout FlatBufferBuilder,
    seqDim: Int32 = 0,
    batchDim: Int32 = 0
  ) -> Offset {
    let __start = tflite_ReverseSequenceOptions.startReverseSequenceOptions(&fbb)
    tflite_ReverseSequenceOptions.add(seqDim: seqDim, &fbb)
    tflite_ReverseSequenceOptions.add(batchDim: batchDim, &fbb)
    return tflite_ReverseSequenceOptions.endReverseSequenceOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.seqDim.p, fieldName: "seqDim", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.batchDim.p, fieldName: "batchDim", required: false, type: Int32.self)
    _v.finish()
  }
}

public struct tflite_MatrixDiagOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_MatrixDiagOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startMatrixDiagOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endMatrixDiagOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_QuantizeOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_QuantizeOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startQuantizeOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endQuantizeOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_MatrixSetDiagOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_MatrixSetDiagOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startMatrixSetDiagOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endMatrixSetDiagOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_IfOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_IfOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case thenSubgraphIndex = 4
    case elseSubgraphIndex = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var thenSubgraphIndex: Int32 { let o = _accessor.offset(VTOFFSET.thenSubgraphIndex.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var elseSubgraphIndex: Int32 { let o = _accessor.offset(VTOFFSET.elseSubgraphIndex.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startIfOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(thenSubgraphIndex: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: thenSubgraphIndex, def: 0, at: VTOFFSET.thenSubgraphIndex.p) }
  public static func add(elseSubgraphIndex: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: elseSubgraphIndex, def: 0, at: VTOFFSET.elseSubgraphIndex.p) }
  public static func endIfOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createIfOptions(
    _ fbb: inout FlatBufferBuilder,
    thenSubgraphIndex: Int32 = 0,
    elseSubgraphIndex: Int32 = 0
  ) -> Offset {
    let __start = tflite_IfOptions.startIfOptions(&fbb)
    tflite_IfOptions.add(thenSubgraphIndex: thenSubgraphIndex, &fbb)
    tflite_IfOptions.add(elseSubgraphIndex: elseSubgraphIndex, &fbb)
    return tflite_IfOptions.endIfOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.thenSubgraphIndex.p, fieldName: "thenSubgraphIndex", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.elseSubgraphIndex.p, fieldName: "elseSubgraphIndex", required: false, type: Int32.self)
    _v.finish()
  }
}

public struct tflite_CallOnceOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_CallOnceOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case initSubgraphIndex = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var initSubgraphIndex: Int32 { let o = _accessor.offset(VTOFFSET.initSubgraphIndex.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startCallOnceOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(initSubgraphIndex: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: initSubgraphIndex, def: 0, at: VTOFFSET.initSubgraphIndex.p) }
  public static func endCallOnceOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCallOnceOptions(
    _ fbb: inout FlatBufferBuilder,
    initSubgraphIndex: Int32 = 0
  ) -> Offset {
    let __start = tflite_CallOnceOptions.startCallOnceOptions(&fbb)
    tflite_CallOnceOptions.add(initSubgraphIndex: initSubgraphIndex, &fbb)
    return tflite_CallOnceOptions.endCallOnceOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.initSubgraphIndex.p, fieldName: "initSubgraphIndex", required: false, type: Int32.self)
    _v.finish()
  }
}

public struct tflite_WhileOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_WhileOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case condSubgraphIndex = 4
    case bodySubgraphIndex = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var condSubgraphIndex: Int32 { let o = _accessor.offset(VTOFFSET.condSubgraphIndex.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var bodySubgraphIndex: Int32 { let o = _accessor.offset(VTOFFSET.bodySubgraphIndex.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startWhileOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(condSubgraphIndex: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: condSubgraphIndex, def: 0, at: VTOFFSET.condSubgraphIndex.p) }
  public static func add(bodySubgraphIndex: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: bodySubgraphIndex, def: 0, at: VTOFFSET.bodySubgraphIndex.p) }
  public static func endWhileOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createWhileOptions(
    _ fbb: inout FlatBufferBuilder,
    condSubgraphIndex: Int32 = 0,
    bodySubgraphIndex: Int32 = 0
  ) -> Offset {
    let __start = tflite_WhileOptions.startWhileOptions(&fbb)
    tflite_WhileOptions.add(condSubgraphIndex: condSubgraphIndex, &fbb)
    tflite_WhileOptions.add(bodySubgraphIndex: bodySubgraphIndex, &fbb)
    return tflite_WhileOptions.endWhileOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.condSubgraphIndex.p, fieldName: "condSubgraphIndex", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.bodySubgraphIndex.p, fieldName: "bodySubgraphIndex", required: false, type: Int32.self)
    _v.finish()
  }
}

public struct tflite_NonMaxSuppressionV4Options: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_NonMaxSuppressionV4Options.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startNonMaxSuppressionV4Options(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endNonMaxSuppressionV4Options(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_NonMaxSuppressionV5Options: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_NonMaxSuppressionV5Options.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startNonMaxSuppressionV5Options(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endNonMaxSuppressionV5Options(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_ScatterNdOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_ScatterNdOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startScatterNdOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endScatterNdOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_SelectV2Options: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_SelectV2Options.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startSelectV2Options(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endSelectV2Options(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_DensifyOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_DensifyOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startDensifyOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endDensifyOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_SegmentSumOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_SegmentSumOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startSegmentSumOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endSegmentSumOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_BatchMatMulOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_BatchMatMulOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case adjX = 4
    case adjY = 6
    case asymmetricQuantizeInputs = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var adjX: Bool { let o = _accessor.offset(VTOFFSET.adjX.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var adjY: Bool { let o = _accessor.offset(VTOFFSET.adjY.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var asymmetricQuantizeInputs: Bool { let o = _accessor.offset(VTOFFSET.asymmetricQuantizeInputs.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startBatchMatMulOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(adjX: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: adjX, def: false,
   at: VTOFFSET.adjX.p) }
  public static func add(adjY: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: adjY, def: false,
   at: VTOFFSET.adjY.p) }
  public static func add(asymmetricQuantizeInputs: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: asymmetricQuantizeInputs, def: false,
   at: VTOFFSET.asymmetricQuantizeInputs.p) }
  public static func endBatchMatMulOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createBatchMatMulOptions(
    _ fbb: inout FlatBufferBuilder,
    adjX: Bool = false,
    adjY: Bool = false,
    asymmetricQuantizeInputs: Bool = false
  ) -> Offset {
    let __start = tflite_BatchMatMulOptions.startBatchMatMulOptions(&fbb)
    tflite_BatchMatMulOptions.add(adjX: adjX, &fbb)
    tflite_BatchMatMulOptions.add(adjY: adjY, &fbb)
    tflite_BatchMatMulOptions.add(asymmetricQuantizeInputs: asymmetricQuantizeInputs, &fbb)
    return tflite_BatchMatMulOptions.endBatchMatMulOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.adjX.p, fieldName: "adjX", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.adjY.p, fieldName: "adjY", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.asymmetricQuantizeInputs.p, fieldName: "asymmetricQuantizeInputs", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct tflite_CumsumOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_CumsumOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case exclusive = 4
    case reverse = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var exclusive: Bool { let o = _accessor.offset(VTOFFSET.exclusive.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var reverse: Bool { let o = _accessor.offset(VTOFFSET.reverse.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startCumsumOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(exclusive: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: exclusive, def: false,
   at: VTOFFSET.exclusive.p) }
  public static func add(reverse: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: reverse, def: false,
   at: VTOFFSET.reverse.p) }
  public static func endCumsumOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCumsumOptions(
    _ fbb: inout FlatBufferBuilder,
    exclusive: Bool = false,
    reverse: Bool = false
  ) -> Offset {
    let __start = tflite_CumsumOptions.startCumsumOptions(&fbb)
    tflite_CumsumOptions.add(exclusive: exclusive, &fbb)
    tflite_CumsumOptions.add(reverse: reverse, &fbb)
    return tflite_CumsumOptions.endCumsumOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.exclusive.p, fieldName: "exclusive", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.reverse.p, fieldName: "reverse", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct tflite_BroadcastToOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_BroadcastToOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startBroadcastToOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endBroadcastToOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_Rfft2dOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_Rfft2dOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startRfft2dOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endRfft2dOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_HashtableOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_HashtableOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case tableId = 4
    case keyDtype = 6
    case valueDtype = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var tableId: Int32 { let o = _accessor.offset(VTOFFSET.tableId.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var keyDtype: tflite_TensorType { let o = _accessor.offset(VTOFFSET.keyDtype.v); return o == 0 ? .float32 : tflite_TensorType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .float32 }
  public var valueDtype: tflite_TensorType { let o = _accessor.offset(VTOFFSET.valueDtype.v); return o == 0 ? .float32 : tflite_TensorType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .float32 }
  public static func startHashtableOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(tableId: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: tableId, def: 0, at: VTOFFSET.tableId.p) }
  public static func add(keyDtype: tflite_TensorType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: keyDtype.rawValue, def: 0, at: VTOFFSET.keyDtype.p) }
  public static func add(valueDtype: tflite_TensorType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: valueDtype.rawValue, def: 0, at: VTOFFSET.valueDtype.p) }
  public static func endHashtableOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createHashtableOptions(
    _ fbb: inout FlatBufferBuilder,
    tableId: Int32 = 0,
    keyDtype: tflite_TensorType = .float32,
    valueDtype: tflite_TensorType = .float32
  ) -> Offset {
    let __start = tflite_HashtableOptions.startHashtableOptions(&fbb)
    tflite_HashtableOptions.add(tableId: tableId, &fbb)
    tflite_HashtableOptions.add(keyDtype: keyDtype, &fbb)
    tflite_HashtableOptions.add(valueDtype: valueDtype, &fbb)
    return tflite_HashtableOptions.endHashtableOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.tableId.p, fieldName: "tableId", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.keyDtype.p, fieldName: "keyDtype", required: false, type: tflite_TensorType.self)
    try _v.visit(field: VTOFFSET.valueDtype.p, fieldName: "valueDtype", required: false, type: tflite_TensorType.self)
    _v.finish()
  }
}

public struct tflite_HashtableFindOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_HashtableFindOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startHashtableFindOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endHashtableFindOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_HashtableImportOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_HashtableImportOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startHashtableImportOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endHashtableImportOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_HashtableSizeOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_HashtableSizeOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startHashtableSizeOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endHashtableSizeOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_VarHandleOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_VarHandleOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case container = 4
    case sharedName = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var container: String? { let o = _accessor.offset(VTOFFSET.container.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var containerSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.container.v) }
  public var sharedName: String? { let o = _accessor.offset(VTOFFSET.sharedName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var sharedNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sharedName.v) }
  public static func startVarHandleOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(container: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: container, at: VTOFFSET.container.p) }
  public static func add(sharedName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sharedName, at: VTOFFSET.sharedName.p) }
  public static func endVarHandleOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createVarHandleOptions(
    _ fbb: inout FlatBufferBuilder,
    containerOffset container: Offset = Offset(),
    sharedNameOffset sharedName: Offset = Offset()
  ) -> Offset {
    let __start = tflite_VarHandleOptions.startVarHandleOptions(&fbb)
    tflite_VarHandleOptions.add(container: container, &fbb)
    tflite_VarHandleOptions.add(sharedName: sharedName, &fbb)
    return tflite_VarHandleOptions.endVarHandleOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.container.p, fieldName: "container", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sharedName.p, fieldName: "sharedName", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct tflite_ReadVariableOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_ReadVariableOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startReadVariableOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endReadVariableOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_AssignVariableOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_AssignVariableOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startAssignVariableOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endAssignVariableOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_RandomOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_RandomOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case seed = 4
    case seed2 = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var seed: Int64 { let o = _accessor.offset(VTOFFSET.seed.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var seed2: Int64 { let o = _accessor.offset(VTOFFSET.seed2.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public static func startRandomOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(seed: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: seed, def: 0, at: VTOFFSET.seed.p) }
  public static func add(seed2: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: seed2, def: 0, at: VTOFFSET.seed2.p) }
  public static func endRandomOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createRandomOptions(
    _ fbb: inout FlatBufferBuilder,
    seed: Int64 = 0,
    seed2: Int64 = 0
  ) -> Offset {
    let __start = tflite_RandomOptions.startRandomOptions(&fbb)
    tflite_RandomOptions.add(seed: seed, &fbb)
    tflite_RandomOptions.add(seed2: seed2, &fbb)
    return tflite_RandomOptions.endRandomOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.seed.p, fieldName: "seed", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.seed2.p, fieldName: "seed2", required: false, type: Int64.self)
    _v.finish()
  }
}

public struct tflite_BucketizeOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_BucketizeOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case boundaries = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasBoundaries: Bool { let o = _accessor.offset(VTOFFSET.boundaries.v); return o == 0 ? false : true }
  public var boundariesCount: Int32 { let o = _accessor.offset(VTOFFSET.boundaries.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func boundaries(at index: Int32) -> Float32 { let o = _accessor.offset(VTOFFSET.boundaries.v); return o == 0 ? 0 : _accessor.directRead(of: Float32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var boundaries: [Float32] { return _accessor.getVector(at: VTOFFSET.boundaries.v) ?? [] }
  public static func startBucketizeOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(boundaries: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: boundaries, at: VTOFFSET.boundaries.p) }
  public static func endBucketizeOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createBucketizeOptions(
    _ fbb: inout FlatBufferBuilder,
    boundariesVectorOffset boundaries: Offset = Offset()
  ) -> Offset {
    let __start = tflite_BucketizeOptions.startBucketizeOptions(&fbb)
    tflite_BucketizeOptions.addVectorOf(boundaries: boundaries, &fbb)
    return tflite_BucketizeOptions.endBucketizeOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.boundaries.p, fieldName: "boundaries", required: false, type: ForwardOffset<Vector<Float32, Float32>>.self)
    _v.finish()
  }
}

public struct tflite_GeluOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_GeluOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case approximate = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var approximate: Bool { let o = _accessor.offset(VTOFFSET.approximate.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startGeluOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(approximate: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: approximate, def: false,
   at: VTOFFSET.approximate.p) }
  public static func endGeluOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createGeluOptions(
    _ fbb: inout FlatBufferBuilder,
    approximate: Bool = false
  ) -> Offset {
    let __start = tflite_GeluOptions.startGeluOptions(&fbb)
    tflite_GeluOptions.add(approximate: approximate, &fbb)
    return tflite_GeluOptions.endGeluOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.approximate.p, fieldName: "approximate", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct tflite_DynamicUpdateSliceOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_DynamicUpdateSliceOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startDynamicUpdateSliceOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endDynamicUpdateSliceOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_UnsortedSegmentProdOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_UnsortedSegmentProdOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startUnsortedSegmentProdOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endUnsortedSegmentProdOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_UnsortedSegmentMaxOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_UnsortedSegmentMaxOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startUnsortedSegmentMaxOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endUnsortedSegmentMaxOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_UnsortedSegmentSumOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_UnsortedSegmentSumOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startUnsortedSegmentSumOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endUnsortedSegmentSumOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_ATan2Options: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_ATan2Options.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startATan2Options(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endATan2Options(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_UnsortedSegmentMinOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_UnsortedSegmentMinOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startUnsortedSegmentMinOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endUnsortedSegmentMinOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_SignOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_SignOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startSignOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endSignOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_BitcastOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_BitcastOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startBitcastOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endBitcastOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_BitwiseXorOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_BitwiseXorOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startBitwiseXorOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endBitwiseXorOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_RightShiftOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_RightShiftOptions.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startRightShiftOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endRightShiftOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

public struct tflite_OperatorCode: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_OperatorCode.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case deprecatedBuiltinCode = 4
    case customCode = 6
    case version = 8
    case builtinCode = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var deprecatedBuiltinCode: Int8 { let o = _accessor.offset(VTOFFSET.deprecatedBuiltinCode.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int8.self, at: o) }
  public var customCode: String? { let o = _accessor.offset(VTOFFSET.customCode.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var customCodeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.customCode.v) }
  public var version: Int32 { let o = _accessor.offset(VTOFFSET.version.v); return o == 0 ? 1 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var builtinCode: tflite_BuiltinOperator { let o = _accessor.offset(VTOFFSET.builtinCode.v); return o == 0 ? .add : tflite_BuiltinOperator(rawValue: _accessor.readBuffer(of: Int32.self, at: o)) ?? .add }
  public static func startOperatorCode(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(deprecatedBuiltinCode: Int8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: deprecatedBuiltinCode, def: 0, at: VTOFFSET.deprecatedBuiltinCode.p) }
  public static func add(customCode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: customCode, at: VTOFFSET.customCode.p) }
  public static func add(version: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: version, def: 1, at: VTOFFSET.version.p) }
  public static func add(builtinCode: tflite_BuiltinOperator, _ fbb: inout FlatBufferBuilder) { fbb.add(element: builtinCode.rawValue, def: 0, at: VTOFFSET.builtinCode.p) }
  public static func endOperatorCode(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createOperatorCode(
    _ fbb: inout FlatBufferBuilder,
    deprecatedBuiltinCode: Int8 = 0,
    customCodeOffset customCode: Offset = Offset(),
    version: Int32 = 1,
    builtinCode: tflite_BuiltinOperator = .add
  ) -> Offset {
    let __start = tflite_OperatorCode.startOperatorCode(&fbb)
    tflite_OperatorCode.add(deprecatedBuiltinCode: deprecatedBuiltinCode, &fbb)
    tflite_OperatorCode.add(customCode: customCode, &fbb)
    tflite_OperatorCode.add(version: version, &fbb)
    tflite_OperatorCode.add(builtinCode: builtinCode, &fbb)
    return tflite_OperatorCode.endOperatorCode(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.deprecatedBuiltinCode.p, fieldName: "deprecatedBuiltinCode", required: false, type: Int8.self)
    try _v.visit(field: VTOFFSET.customCode.p, fieldName: "customCode", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.version.p, fieldName: "version", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.builtinCode.p, fieldName: "builtinCode", required: false, type: tflite_BuiltinOperator.self)
    _v.finish()
  }
}

public struct tflite_Operator: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_Operator.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case opcodeIndex = 4
    case inputs = 6
    case outputs = 8
    case builtinOptionsType = 10
    case builtinOptions = 12
    case customOptions = 14
    case customOptionsFormat = 16
    case mutatingVariableInputs = 18
    case intermediates = 20
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var opcodeIndex: UInt32 { let o = _accessor.offset(VTOFFSET.opcodeIndex.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var hasInputs: Bool { let o = _accessor.offset(VTOFFSET.inputs.v); return o == 0 ? false : true }
  public var inputsCount: Int32 { let o = _accessor.offset(VTOFFSET.inputs.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func inputs(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.inputs.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var inputs: [Int32] { return _accessor.getVector(at: VTOFFSET.inputs.v) ?? [] }
  public var hasOutputs: Bool { let o = _accessor.offset(VTOFFSET.outputs.v); return o == 0 ? false : true }
  public var outputsCount: Int32 { let o = _accessor.offset(VTOFFSET.outputs.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func outputs(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.outputs.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var outputs: [Int32] { return _accessor.getVector(at: VTOFFSET.outputs.v) ?? [] }
  public var builtinOptionsType: tflite_BuiltinOptions { let o = _accessor.offset(VTOFFSET.builtinOptionsType.v); return o == 0 ? .none_ : tflite_BuiltinOptions(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none_ }
  public func builtinOptions<T: FlatbuffersInitializable>(type: T.Type) -> T? { let o = _accessor.offset(VTOFFSET.builtinOptions.v); return o == 0 ? nil : _accessor.union(o) }
  public var hasCustomOptions: Bool { let o = _accessor.offset(VTOFFSET.customOptions.v); return o == 0 ? false : true }
  public var customOptionsCount: Int32 { let o = _accessor.offset(VTOFFSET.customOptions.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func customOptions(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.customOptions.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var customOptions: [UInt8] { return _accessor.getVector(at: VTOFFSET.customOptions.v) ?? [] }
  public var customOptionsFormat: tflite_CustomOptionsFormat { let o = _accessor.offset(VTOFFSET.customOptionsFormat.v); return o == 0 ? .flexbuffers : tflite_CustomOptionsFormat(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .flexbuffers }
  public var hasMutatingVariableInputs: Bool { let o = _accessor.offset(VTOFFSET.mutatingVariableInputs.v); return o == 0 ? false : true }
  public var mutatingVariableInputsCount: Int32 { let o = _accessor.offset(VTOFFSET.mutatingVariableInputs.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func mutatingVariableInputs(at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.mutatingVariableInputs.v); return o == 0 ? true : _accessor.directRead(of: Bool.self, offset: _accessor.vector(at: o) + index * 1) }
  public var mutatingVariableInputs: [Bool] { return _accessor.getVector(at: VTOFFSET.mutatingVariableInputs.v) ?? [] }
  public var hasIntermediates: Bool { let o = _accessor.offset(VTOFFSET.intermediates.v); return o == 0 ? false : true }
  public var intermediatesCount: Int32 { let o = _accessor.offset(VTOFFSET.intermediates.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func intermediates(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.intermediates.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var intermediates: [Int32] { return _accessor.getVector(at: VTOFFSET.intermediates.v) ?? [] }
  public static func startOperator(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 9) }
  public static func add(opcodeIndex: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: opcodeIndex, def: 0, at: VTOFFSET.opcodeIndex.p) }
  public static func addVectorOf(inputs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: inputs, at: VTOFFSET.inputs.p) }
  public static func addVectorOf(outputs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: outputs, at: VTOFFSET.outputs.p) }
  public static func add(builtinOptionsType: tflite_BuiltinOptions, _ fbb: inout FlatBufferBuilder) { fbb.add(element: builtinOptionsType.rawValue, def: 0, at: VTOFFSET.builtinOptionsType.p) }
  public static func add(builtinOptions: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: builtinOptions, at: VTOFFSET.builtinOptions.p) }
  public static func addVectorOf(customOptions: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: customOptions, at: VTOFFSET.customOptions.p) }
  public static func add(customOptionsFormat: tflite_CustomOptionsFormat, _ fbb: inout FlatBufferBuilder) { fbb.add(element: customOptionsFormat.rawValue, def: 0, at: VTOFFSET.customOptionsFormat.p) }
  public static func addVectorOf(mutatingVariableInputs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: mutatingVariableInputs, at: VTOFFSET.mutatingVariableInputs.p) }
  public static func addVectorOf(intermediates: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: intermediates, at: VTOFFSET.intermediates.p) }
  public static func endOperator(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createOperator(
    _ fbb: inout FlatBufferBuilder,
    opcodeIndex: UInt32 = 0,
    inputsVectorOffset inputs: Offset = Offset(),
    outputsVectorOffset outputs: Offset = Offset(),
    builtinOptionsType: tflite_BuiltinOptions = .none_,
    builtinOptionsOffset builtinOptions: Offset = Offset(),
    customOptionsVectorOffset customOptions: Offset = Offset(),
    customOptionsFormat: tflite_CustomOptionsFormat = .flexbuffers,
    mutatingVariableInputsVectorOffset mutatingVariableInputs: Offset = Offset(),
    intermediatesVectorOffset intermediates: Offset = Offset()
  ) -> Offset {
    let __start = tflite_Operator.startOperator(&fbb)
    tflite_Operator.add(opcodeIndex: opcodeIndex, &fbb)
    tflite_Operator.addVectorOf(inputs: inputs, &fbb)
    tflite_Operator.addVectorOf(outputs: outputs, &fbb)
    tflite_Operator.add(builtinOptionsType: builtinOptionsType, &fbb)
    tflite_Operator.add(builtinOptions: builtinOptions, &fbb)
    tflite_Operator.addVectorOf(customOptions: customOptions, &fbb)
    tflite_Operator.add(customOptionsFormat: customOptionsFormat, &fbb)
    tflite_Operator.addVectorOf(mutatingVariableInputs: mutatingVariableInputs, &fbb)
    tflite_Operator.addVectorOf(intermediates: intermediates, &fbb)
    return tflite_Operator.endOperator(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.opcodeIndex.p, fieldName: "opcodeIndex", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.inputs.p, fieldName: "inputs", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(field: VTOFFSET.outputs.p, fieldName: "outputs", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(unionKey: VTOFFSET.builtinOptionsType.p, unionField: VTOFFSET.builtinOptions.p, unionKeyName: "builtinOptionsType", fieldName: "builtinOptions", required: false, completion: { (verifier, key: tflite_BuiltinOptions, pos) in
      switch key {
      case .none_:
        break // NOTE - SWIFT doesnt support none
      case .conv2doptions:
        try ForwardOffset<tflite_Conv2DOptions>.verify(&verifier, at: pos, of: tflite_Conv2DOptions.self)
      case .depthwiseconv2doptions:
        try ForwardOffset<tflite_DepthwiseConv2DOptions>.verify(&verifier, at: pos, of: tflite_DepthwiseConv2DOptions.self)
      case .concatembeddingsoptions:
        try ForwardOffset<tflite_ConcatEmbeddingsOptions>.verify(&verifier, at: pos, of: tflite_ConcatEmbeddingsOptions.self)
      case .lshprojectionoptions:
        try ForwardOffset<tflite_LSHProjectionOptions>.verify(&verifier, at: pos, of: tflite_LSHProjectionOptions.self)
      case .pool2doptions:
        try ForwardOffset<tflite_Pool2DOptions>.verify(&verifier, at: pos, of: tflite_Pool2DOptions.self)
      case .svdfoptions:
        try ForwardOffset<tflite_SVDFOptions>.verify(&verifier, at: pos, of: tflite_SVDFOptions.self)
      case .rnnoptions:
        try ForwardOffset<tflite_RNNOptions>.verify(&verifier, at: pos, of: tflite_RNNOptions.self)
      case .fullyconnectedoptions:
        try ForwardOffset<tflite_FullyConnectedOptions>.verify(&verifier, at: pos, of: tflite_FullyConnectedOptions.self)
      case .softmaxoptions:
        try ForwardOffset<tflite_SoftmaxOptions>.verify(&verifier, at: pos, of: tflite_SoftmaxOptions.self)
      case .concatenationoptions:
        try ForwardOffset<tflite_ConcatenationOptions>.verify(&verifier, at: pos, of: tflite_ConcatenationOptions.self)
      case .addoptions:
        try ForwardOffset<tflite_AddOptions>.verify(&verifier, at: pos, of: tflite_AddOptions.self)
      case .l2normoptions:
        try ForwardOffset<tflite_L2NormOptions>.verify(&verifier, at: pos, of: tflite_L2NormOptions.self)
      case .localresponsenormalizationoptions:
        try ForwardOffset<tflite_LocalResponseNormalizationOptions>.verify(&verifier, at: pos, of: tflite_LocalResponseNormalizationOptions.self)
      case .lstmoptions:
        try ForwardOffset<tflite_LSTMOptions>.verify(&verifier, at: pos, of: tflite_LSTMOptions.self)
      case .resizebilinearoptions:
        try ForwardOffset<tflite_ResizeBilinearOptions>.verify(&verifier, at: pos, of: tflite_ResizeBilinearOptions.self)
      case .calloptions:
        try ForwardOffset<tflite_CallOptions>.verify(&verifier, at: pos, of: tflite_CallOptions.self)
      case .reshapeoptions:
        try ForwardOffset<tflite_ReshapeOptions>.verify(&verifier, at: pos, of: tflite_ReshapeOptions.self)
      case .skipgramoptions:
        try ForwardOffset<tflite_SkipGramOptions>.verify(&verifier, at: pos, of: tflite_SkipGramOptions.self)
      case .spacetodepthoptions:
        try ForwardOffset<tflite_SpaceToDepthOptions>.verify(&verifier, at: pos, of: tflite_SpaceToDepthOptions.self)
      case .embeddinglookupsparseoptions:
        try ForwardOffset<tflite_EmbeddingLookupSparseOptions>.verify(&verifier, at: pos, of: tflite_EmbeddingLookupSparseOptions.self)
      case .muloptions:
        try ForwardOffset<tflite_MulOptions>.verify(&verifier, at: pos, of: tflite_MulOptions.self)
      case .padoptions:
        try ForwardOffset<tflite_PadOptions>.verify(&verifier, at: pos, of: tflite_PadOptions.self)
      case .gatheroptions:
        try ForwardOffset<tflite_GatherOptions>.verify(&verifier, at: pos, of: tflite_GatherOptions.self)
      case .batchtospacendoptions:
        try ForwardOffset<tflite_BatchToSpaceNDOptions>.verify(&verifier, at: pos, of: tflite_BatchToSpaceNDOptions.self)
      case .spacetobatchndoptions:
        try ForwardOffset<tflite_SpaceToBatchNDOptions>.verify(&verifier, at: pos, of: tflite_SpaceToBatchNDOptions.self)
      case .transposeoptions:
        try ForwardOffset<tflite_TransposeOptions>.verify(&verifier, at: pos, of: tflite_TransposeOptions.self)
      case .reduceroptions:
        try ForwardOffset<tflite_ReducerOptions>.verify(&verifier, at: pos, of: tflite_ReducerOptions.self)
      case .suboptions:
        try ForwardOffset<tflite_SubOptions>.verify(&verifier, at: pos, of: tflite_SubOptions.self)
      case .divoptions:
        try ForwardOffset<tflite_DivOptions>.verify(&verifier, at: pos, of: tflite_DivOptions.self)
      case .squeezeoptions:
        try ForwardOffset<tflite_SqueezeOptions>.verify(&verifier, at: pos, of: tflite_SqueezeOptions.self)
      case .sequencernnoptions:
        try ForwardOffset<tflite_SequenceRNNOptions>.verify(&verifier, at: pos, of: tflite_SequenceRNNOptions.self)
      case .stridedsliceoptions:
        try ForwardOffset<tflite_StridedSliceOptions>.verify(&verifier, at: pos, of: tflite_StridedSliceOptions.self)
      case .expoptions:
        try ForwardOffset<tflite_ExpOptions>.verify(&verifier, at: pos, of: tflite_ExpOptions.self)
      case .topkv2options:
        try ForwardOffset<tflite_TopKV2Options>.verify(&verifier, at: pos, of: tflite_TopKV2Options.self)
      case .splitoptions:
        try ForwardOffset<tflite_SplitOptions>.verify(&verifier, at: pos, of: tflite_SplitOptions.self)
      case .logsoftmaxoptions:
        try ForwardOffset<tflite_LogSoftmaxOptions>.verify(&verifier, at: pos, of: tflite_LogSoftmaxOptions.self)
      case .castoptions:
        try ForwardOffset<tflite_CastOptions>.verify(&verifier, at: pos, of: tflite_CastOptions.self)
      case .dequantizeoptions:
        try ForwardOffset<tflite_DequantizeOptions>.verify(&verifier, at: pos, of: tflite_DequantizeOptions.self)
      case .maximumminimumoptions:
        try ForwardOffset<tflite_MaximumMinimumOptions>.verify(&verifier, at: pos, of: tflite_MaximumMinimumOptions.self)
      case .argmaxoptions:
        try ForwardOffset<tflite_ArgMaxOptions>.verify(&verifier, at: pos, of: tflite_ArgMaxOptions.self)
      case .lessoptions:
        try ForwardOffset<tflite_LessOptions>.verify(&verifier, at: pos, of: tflite_LessOptions.self)
      case .negoptions:
        try ForwardOffset<tflite_NegOptions>.verify(&verifier, at: pos, of: tflite_NegOptions.self)
      case .padv2options:
        try ForwardOffset<tflite_PadV2Options>.verify(&verifier, at: pos, of: tflite_PadV2Options.self)
      case .greateroptions:
        try ForwardOffset<tflite_GreaterOptions>.verify(&verifier, at: pos, of: tflite_GreaterOptions.self)
      case .greaterequaloptions:
        try ForwardOffset<tflite_GreaterEqualOptions>.verify(&verifier, at: pos, of: tflite_GreaterEqualOptions.self)
      case .lessequaloptions:
        try ForwardOffset<tflite_LessEqualOptions>.verify(&verifier, at: pos, of: tflite_LessEqualOptions.self)
      case .selectoptions:
        try ForwardOffset<tflite_SelectOptions>.verify(&verifier, at: pos, of: tflite_SelectOptions.self)
      case .sliceoptions:
        try ForwardOffset<tflite_SliceOptions>.verify(&verifier, at: pos, of: tflite_SliceOptions.self)
      case .transposeconvoptions:
        try ForwardOffset<tflite_TransposeConvOptions>.verify(&verifier, at: pos, of: tflite_TransposeConvOptions.self)
      case .sparsetodenseoptions:
        try ForwardOffset<tflite_SparseToDenseOptions>.verify(&verifier, at: pos, of: tflite_SparseToDenseOptions.self)
      case .tileoptions:
        try ForwardOffset<tflite_TileOptions>.verify(&verifier, at: pos, of: tflite_TileOptions.self)
      case .expanddimsoptions:
        try ForwardOffset<tflite_ExpandDimsOptions>.verify(&verifier, at: pos, of: tflite_ExpandDimsOptions.self)
      case .equaloptions:
        try ForwardOffset<tflite_EqualOptions>.verify(&verifier, at: pos, of: tflite_EqualOptions.self)
      case .notequaloptions:
        try ForwardOffset<tflite_NotEqualOptions>.verify(&verifier, at: pos, of: tflite_NotEqualOptions.self)
      case .shapeoptions:
        try ForwardOffset<tflite_ShapeOptions>.verify(&verifier, at: pos, of: tflite_ShapeOptions.self)
      case .powoptions:
        try ForwardOffset<tflite_PowOptions>.verify(&verifier, at: pos, of: tflite_PowOptions.self)
      case .argminoptions:
        try ForwardOffset<tflite_ArgMinOptions>.verify(&verifier, at: pos, of: tflite_ArgMinOptions.self)
      case .fakequantoptions:
        try ForwardOffset<tflite_FakeQuantOptions>.verify(&verifier, at: pos, of: tflite_FakeQuantOptions.self)
      case .packoptions:
        try ForwardOffset<tflite_PackOptions>.verify(&verifier, at: pos, of: tflite_PackOptions.self)
      case .logicaloroptions:
        try ForwardOffset<tflite_LogicalOrOptions>.verify(&verifier, at: pos, of: tflite_LogicalOrOptions.self)
      case .onehotoptions:
        try ForwardOffset<tflite_OneHotOptions>.verify(&verifier, at: pos, of: tflite_OneHotOptions.self)
      case .logicalandoptions:
        try ForwardOffset<tflite_LogicalAndOptions>.verify(&verifier, at: pos, of: tflite_LogicalAndOptions.self)
      case .logicalnotoptions:
        try ForwardOffset<tflite_LogicalNotOptions>.verify(&verifier, at: pos, of: tflite_LogicalNotOptions.self)
      case .unpackoptions:
        try ForwardOffset<tflite_UnpackOptions>.verify(&verifier, at: pos, of: tflite_UnpackOptions.self)
      case .floordivoptions:
        try ForwardOffset<tflite_FloorDivOptions>.verify(&verifier, at: pos, of: tflite_FloorDivOptions.self)
      case .squareoptions:
        try ForwardOffset<tflite_SquareOptions>.verify(&verifier, at: pos, of: tflite_SquareOptions.self)
      case .zeroslikeoptions:
        try ForwardOffset<tflite_ZerosLikeOptions>.verify(&verifier, at: pos, of: tflite_ZerosLikeOptions.self)
      case .filloptions:
        try ForwardOffset<tflite_FillOptions>.verify(&verifier, at: pos, of: tflite_FillOptions.self)
      case .bidirectionalsequencelstmoptions:
        try ForwardOffset<tflite_BidirectionalSequenceLSTMOptions>.verify(&verifier, at: pos, of: tflite_BidirectionalSequenceLSTMOptions.self)
      case .bidirectionalsequencernnoptions:
        try ForwardOffset<tflite_BidirectionalSequenceRNNOptions>.verify(&verifier, at: pos, of: tflite_BidirectionalSequenceRNNOptions.self)
      case .unidirectionalsequencelstmoptions:
        try ForwardOffset<tflite_UnidirectionalSequenceLSTMOptions>.verify(&verifier, at: pos, of: tflite_UnidirectionalSequenceLSTMOptions.self)
      case .floormodoptions:
        try ForwardOffset<tflite_FloorModOptions>.verify(&verifier, at: pos, of: tflite_FloorModOptions.self)
      case .rangeoptions:
        try ForwardOffset<tflite_RangeOptions>.verify(&verifier, at: pos, of: tflite_RangeOptions.self)
      case .resizenearestneighboroptions:
        try ForwardOffset<tflite_ResizeNearestNeighborOptions>.verify(&verifier, at: pos, of: tflite_ResizeNearestNeighborOptions.self)
      case .leakyreluoptions:
        try ForwardOffset<tflite_LeakyReluOptions>.verify(&verifier, at: pos, of: tflite_LeakyReluOptions.self)
      case .squareddifferenceoptions:
        try ForwardOffset<tflite_SquaredDifferenceOptions>.verify(&verifier, at: pos, of: tflite_SquaredDifferenceOptions.self)
      case .mirrorpadoptions:
        try ForwardOffset<tflite_MirrorPadOptions>.verify(&verifier, at: pos, of: tflite_MirrorPadOptions.self)
      case .absoptions:
        try ForwardOffset<tflite_AbsOptions>.verify(&verifier, at: pos, of: tflite_AbsOptions.self)
      case .splitvoptions:
        try ForwardOffset<tflite_SplitVOptions>.verify(&verifier, at: pos, of: tflite_SplitVOptions.self)
      case .uniqueoptions:
        try ForwardOffset<tflite_UniqueOptions>.verify(&verifier, at: pos, of: tflite_UniqueOptions.self)
      case .reversev2options:
        try ForwardOffset<tflite_ReverseV2Options>.verify(&verifier, at: pos, of: tflite_ReverseV2Options.self)
      case .addnoptions:
        try ForwardOffset<tflite_AddNOptions>.verify(&verifier, at: pos, of: tflite_AddNOptions.self)
      case .gatherndoptions:
        try ForwardOffset<tflite_GatherNdOptions>.verify(&verifier, at: pos, of: tflite_GatherNdOptions.self)
      case .cosoptions:
        try ForwardOffset<tflite_CosOptions>.verify(&verifier, at: pos, of: tflite_CosOptions.self)
      case .whereoptions:
        try ForwardOffset<tflite_WhereOptions>.verify(&verifier, at: pos, of: tflite_WhereOptions.self)
      case .rankoptions:
        try ForwardOffset<tflite_RankOptions>.verify(&verifier, at: pos, of: tflite_RankOptions.self)
      case .reversesequenceoptions:
        try ForwardOffset<tflite_ReverseSequenceOptions>.verify(&verifier, at: pos, of: tflite_ReverseSequenceOptions.self)
      case .matrixdiagoptions:
        try ForwardOffset<tflite_MatrixDiagOptions>.verify(&verifier, at: pos, of: tflite_MatrixDiagOptions.self)
      case .quantizeoptions:
        try ForwardOffset<tflite_QuantizeOptions>.verify(&verifier, at: pos, of: tflite_QuantizeOptions.self)
      case .matrixsetdiagoptions:
        try ForwardOffset<tflite_MatrixSetDiagOptions>.verify(&verifier, at: pos, of: tflite_MatrixSetDiagOptions.self)
      case .hardswishoptions:
        try ForwardOffset<tflite_HardSwishOptions>.verify(&verifier, at: pos, of: tflite_HardSwishOptions.self)
      case .ifoptions:
        try ForwardOffset<tflite_IfOptions>.verify(&verifier, at: pos, of: tflite_IfOptions.self)
      case .whileoptions:
        try ForwardOffset<tflite_WhileOptions>.verify(&verifier, at: pos, of: tflite_WhileOptions.self)
      case .depthtospaceoptions:
        try ForwardOffset<tflite_DepthToSpaceOptions>.verify(&verifier, at: pos, of: tflite_DepthToSpaceOptions.self)
      case .nonmaxsuppressionv4options:
        try ForwardOffset<tflite_NonMaxSuppressionV4Options>.verify(&verifier, at: pos, of: tflite_NonMaxSuppressionV4Options.self)
      case .nonmaxsuppressionv5options:
        try ForwardOffset<tflite_NonMaxSuppressionV5Options>.verify(&verifier, at: pos, of: tflite_NonMaxSuppressionV5Options.self)
      case .scatterndoptions:
        try ForwardOffset<tflite_ScatterNdOptions>.verify(&verifier, at: pos, of: tflite_ScatterNdOptions.self)
      case .selectv2options:
        try ForwardOffset<tflite_SelectV2Options>.verify(&verifier, at: pos, of: tflite_SelectV2Options.self)
      case .densifyoptions:
        try ForwardOffset<tflite_DensifyOptions>.verify(&verifier, at: pos, of: tflite_DensifyOptions.self)
      case .segmentsumoptions:
        try ForwardOffset<tflite_SegmentSumOptions>.verify(&verifier, at: pos, of: tflite_SegmentSumOptions.self)
      case .batchmatmuloptions:
        try ForwardOffset<tflite_BatchMatMulOptions>.verify(&verifier, at: pos, of: tflite_BatchMatMulOptions.self)
      case .cumsumoptions:
        try ForwardOffset<tflite_CumsumOptions>.verify(&verifier, at: pos, of: tflite_CumsumOptions.self)
      case .callonceoptions:
        try ForwardOffset<tflite_CallOnceOptions>.verify(&verifier, at: pos, of: tflite_CallOnceOptions.self)
      case .broadcasttooptions:
        try ForwardOffset<tflite_BroadcastToOptions>.verify(&verifier, at: pos, of: tflite_BroadcastToOptions.self)
      case .rfft2doptions:
        try ForwardOffset<tflite_Rfft2dOptions>.verify(&verifier, at: pos, of: tflite_Rfft2dOptions.self)
      case .conv3doptions:
        try ForwardOffset<tflite_Conv3DOptions>.verify(&verifier, at: pos, of: tflite_Conv3DOptions.self)
      case .hashtableoptions:
        try ForwardOffset<tflite_HashtableOptions>.verify(&verifier, at: pos, of: tflite_HashtableOptions.self)
      case .hashtablefindoptions:
        try ForwardOffset<tflite_HashtableFindOptions>.verify(&verifier, at: pos, of: tflite_HashtableFindOptions.self)
      case .hashtableimportoptions:
        try ForwardOffset<tflite_HashtableImportOptions>.verify(&verifier, at: pos, of: tflite_HashtableImportOptions.self)
      case .hashtablesizeoptions:
        try ForwardOffset<tflite_HashtableSizeOptions>.verify(&verifier, at: pos, of: tflite_HashtableSizeOptions.self)
      case .varhandleoptions:
        try ForwardOffset<tflite_VarHandleOptions>.verify(&verifier, at: pos, of: tflite_VarHandleOptions.self)
      case .readvariableoptions:
        try ForwardOffset<tflite_ReadVariableOptions>.verify(&verifier, at: pos, of: tflite_ReadVariableOptions.self)
      case .assignvariableoptions:
        try ForwardOffset<tflite_AssignVariableOptions>.verify(&verifier, at: pos, of: tflite_AssignVariableOptions.self)
      case .randomoptions:
        try ForwardOffset<tflite_RandomOptions>.verify(&verifier, at: pos, of: tflite_RandomOptions.self)
      case .bucketizeoptions:
        try ForwardOffset<tflite_BucketizeOptions>.verify(&verifier, at: pos, of: tflite_BucketizeOptions.self)
      case .geluoptions:
        try ForwardOffset<tflite_GeluOptions>.verify(&verifier, at: pos, of: tflite_GeluOptions.self)
      case .dynamicupdatesliceoptions:
        try ForwardOffset<tflite_DynamicUpdateSliceOptions>.verify(&verifier, at: pos, of: tflite_DynamicUpdateSliceOptions.self)
      case .unsortedsegmentprodoptions:
        try ForwardOffset<tflite_UnsortedSegmentProdOptions>.verify(&verifier, at: pos, of: tflite_UnsortedSegmentProdOptions.self)
      case .unsortedsegmentmaxoptions:
        try ForwardOffset<tflite_UnsortedSegmentMaxOptions>.verify(&verifier, at: pos, of: tflite_UnsortedSegmentMaxOptions.self)
      case .unsortedsegmentminoptions:
        try ForwardOffset<tflite_UnsortedSegmentMinOptions>.verify(&verifier, at: pos, of: tflite_UnsortedSegmentMinOptions.self)
      case .unsortedsegmentsumoptions:
        try ForwardOffset<tflite_UnsortedSegmentSumOptions>.verify(&verifier, at: pos, of: tflite_UnsortedSegmentSumOptions.self)
      case .atan2options:
        try ForwardOffset<tflite_ATan2Options>.verify(&verifier, at: pos, of: tflite_ATan2Options.self)
      case .signoptions:
        try ForwardOffset<tflite_SignOptions>.verify(&verifier, at: pos, of: tflite_SignOptions.self)
      case .bitcastoptions:
        try ForwardOffset<tflite_BitcastOptions>.verify(&verifier, at: pos, of: tflite_BitcastOptions.self)
      case .bitwisexoroptions:
        try ForwardOffset<tflite_BitwiseXorOptions>.verify(&verifier, at: pos, of: tflite_BitwiseXorOptions.self)
      case .rightshiftoptions:
        try ForwardOffset<tflite_RightShiftOptions>.verify(&verifier, at: pos, of: tflite_RightShiftOptions.self)
      }
    })
    try _v.visit(field: VTOFFSET.customOptions.p, fieldName: "customOptions", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.customOptionsFormat.p, fieldName: "customOptionsFormat", required: false, type: tflite_CustomOptionsFormat.self)
    try _v.visit(field: VTOFFSET.mutatingVariableInputs.p, fieldName: "mutatingVariableInputs", required: false, type: ForwardOffset<Vector<Bool, Bool>>.self)
    try _v.visit(field: VTOFFSET.intermediates.p, fieldName: "intermediates", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    _v.finish()
  }
}

public struct tflite_SubGraph: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_SubGraph.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case tensors = 4
    case inputs = 6
    case outputs = 8
    case operators = 10
    case name = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasTensors: Bool { let o = _accessor.offset(VTOFFSET.tensors.v); return o == 0 ? false : true }
  public var tensorsCount: Int32 { let o = _accessor.offset(VTOFFSET.tensors.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func tensors(at index: Int32) -> tflite_Tensor? { let o = _accessor.offset(VTOFFSET.tensors.v); return o == 0 ? nil : tflite_Tensor(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var hasInputs: Bool { let o = _accessor.offset(VTOFFSET.inputs.v); return o == 0 ? false : true }
  public var inputsCount: Int32 { let o = _accessor.offset(VTOFFSET.inputs.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func inputs(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.inputs.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var inputs: [Int32] { return _accessor.getVector(at: VTOFFSET.inputs.v) ?? [] }
  public var hasOutputs: Bool { let o = _accessor.offset(VTOFFSET.outputs.v); return o == 0 ? false : true }
  public var outputsCount: Int32 { let o = _accessor.offset(VTOFFSET.outputs.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func outputs(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.outputs.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var outputs: [Int32] { return _accessor.getVector(at: VTOFFSET.outputs.v) ?? [] }
  public var hasOperators: Bool { let o = _accessor.offset(VTOFFSET.operators.v); return o == 0 ? false : true }
  public var operatorsCount: Int32 { let o = _accessor.offset(VTOFFSET.operators.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func operators(at index: Int32) -> tflite_Operator? { let o = _accessor.offset(VTOFFSET.operators.v); return o == 0 ? nil : tflite_Operator(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  public static func startSubGraph(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func addVectorOf(tensors: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: tensors, at: VTOFFSET.tensors.p) }
  public static func addVectorOf(inputs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: inputs, at: VTOFFSET.inputs.p) }
  public static func addVectorOf(outputs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: outputs, at: VTOFFSET.outputs.p) }
  public static func addVectorOf(operators: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: operators, at: VTOFFSET.operators.p) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func endSubGraph(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSubGraph(
    _ fbb: inout FlatBufferBuilder,
    tensorsVectorOffset tensors: Offset = Offset(),
    inputsVectorOffset inputs: Offset = Offset(),
    outputsVectorOffset outputs: Offset = Offset(),
    operatorsVectorOffset operators: Offset = Offset(),
    nameOffset name: Offset = Offset()
  ) -> Offset {
    let __start = tflite_SubGraph.startSubGraph(&fbb)
    tflite_SubGraph.addVectorOf(tensors: tensors, &fbb)
    tflite_SubGraph.addVectorOf(inputs: inputs, &fbb)
    tflite_SubGraph.addVectorOf(outputs: outputs, &fbb)
    tflite_SubGraph.addVectorOf(operators: operators, &fbb)
    tflite_SubGraph.add(name: name, &fbb)
    return tflite_SubGraph.endSubGraph(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.tensors.p, fieldName: "tensors", required: false, type: ForwardOffset<Vector<ForwardOffset<tflite_Tensor>, tflite_Tensor>>.self)
    try _v.visit(field: VTOFFSET.inputs.p, fieldName: "inputs", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(field: VTOFFSET.outputs.p, fieldName: "outputs", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(field: VTOFFSET.operators.p, fieldName: "operators", required: false, type: ForwardOffset<Vector<ForwardOffset<tflite_Operator>, tflite_Operator>>.self)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct tflite_Buffer: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_Buffer.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case data = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasData: Bool { let o = _accessor.offset(VTOFFSET.data.v); return o == 0 ? false : true }
  public var dataCount: Int32 { let o = _accessor.offset(VTOFFSET.data.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func data(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.data.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var data: [UInt8] { return _accessor.getVector(at: VTOFFSET.data.v) ?? [] }
  public static func startBuffer(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(data: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: data, at: VTOFFSET.data.p) }
  public static func endBuffer(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createBuffer(
    _ fbb: inout FlatBufferBuilder,
    dataVectorOffset data: Offset = Offset()
  ) -> Offset {
    let __start = tflite_Buffer.startBuffer(&fbb)
    tflite_Buffer.addVectorOf(data: data, &fbb)
    return tflite_Buffer.endBuffer(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.data.p, fieldName: "data", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    _v.finish()
  }
}

public struct tflite_Metadata: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_Metadata.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case name = 4
    case buffer = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  public var buffer: UInt32 { let o = _accessor.offset(VTOFFSET.buffer.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public static func startMetadata(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func add(buffer: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: buffer, def: 0, at: VTOFFSET.buffer.p) }
  public static func endMetadata(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createMetadata(
    _ fbb: inout FlatBufferBuilder,
    nameOffset name: Offset = Offset(),
    buffer: UInt32 = 0
  ) -> Offset {
    let __start = tflite_Metadata.startMetadata(&fbb)
    tflite_Metadata.add(name: name, &fbb)
    tflite_Metadata.add(buffer: buffer, &fbb)
    return tflite_Metadata.endMetadata(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.buffer.p, fieldName: "buffer", required: false, type: UInt32.self)
    _v.finish()
  }
}

public struct tflite_TensorMap: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_TensorMap.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case name = 4
    case tensorIndex = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  public var tensorIndex: UInt32 { let o = _accessor.offset(VTOFFSET.tensorIndex.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public static func startTensorMap(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func add(tensorIndex: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: tensorIndex, def: 0, at: VTOFFSET.tensorIndex.p) }
  public static func endTensorMap(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createTensorMap(
    _ fbb: inout FlatBufferBuilder,
    nameOffset name: Offset = Offset(),
    tensorIndex: UInt32 = 0
  ) -> Offset {
    let __start = tflite_TensorMap.startTensorMap(&fbb)
    tflite_TensorMap.add(name: name, &fbb)
    tflite_TensorMap.add(tensorIndex: tensorIndex, &fbb)
    return tflite_TensorMap.endTensorMap(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.tensorIndex.p, fieldName: "tensorIndex", required: false, type: UInt32.self)
    _v.finish()
  }
}

public struct tflite_SignatureDef: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_SignatureDef.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case inputs = 4
    case outputs = 6
    case signatureKey = 8
    case subgraphIndex = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasInputs: Bool { let o = _accessor.offset(VTOFFSET.inputs.v); return o == 0 ? false : true }
  public var inputsCount: Int32 { let o = _accessor.offset(VTOFFSET.inputs.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func inputs(at index: Int32) -> tflite_TensorMap? { let o = _accessor.offset(VTOFFSET.inputs.v); return o == 0 ? nil : tflite_TensorMap(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var hasOutputs: Bool { let o = _accessor.offset(VTOFFSET.outputs.v); return o == 0 ? false : true }
  public var outputsCount: Int32 { let o = _accessor.offset(VTOFFSET.outputs.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func outputs(at index: Int32) -> tflite_TensorMap? { let o = _accessor.offset(VTOFFSET.outputs.v); return o == 0 ? nil : tflite_TensorMap(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var signatureKey: String? { let o = _accessor.offset(VTOFFSET.signatureKey.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var signatureKeySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.signatureKey.v) }
  public var subgraphIndex: UInt32 { let o = _accessor.offset(VTOFFSET.subgraphIndex.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public static func startSignatureDef(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func addVectorOf(inputs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: inputs, at: VTOFFSET.inputs.p) }
  public static func addVectorOf(outputs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: outputs, at: VTOFFSET.outputs.p) }
  public static func add(signatureKey: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: signatureKey, at: VTOFFSET.signatureKey.p) }
  public static func add(subgraphIndex: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: subgraphIndex, def: 0, at: VTOFFSET.subgraphIndex.p) }
  public static func endSignatureDef(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSignatureDef(
    _ fbb: inout FlatBufferBuilder,
    inputsVectorOffset inputs: Offset = Offset(),
    outputsVectorOffset outputs: Offset = Offset(),
    signatureKeyOffset signatureKey: Offset = Offset(),
    subgraphIndex: UInt32 = 0
  ) -> Offset {
    let __start = tflite_SignatureDef.startSignatureDef(&fbb)
    tflite_SignatureDef.addVectorOf(inputs: inputs, &fbb)
    tflite_SignatureDef.addVectorOf(outputs: outputs, &fbb)
    tflite_SignatureDef.add(signatureKey: signatureKey, &fbb)
    tflite_SignatureDef.add(subgraphIndex: subgraphIndex, &fbb)
    return tflite_SignatureDef.endSignatureDef(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.inputs.p, fieldName: "inputs", required: false, type: ForwardOffset<Vector<ForwardOffset<tflite_TensorMap>, tflite_TensorMap>>.self)
    try _v.visit(field: VTOFFSET.outputs.p, fieldName: "outputs", required: false, type: ForwardOffset<Vector<ForwardOffset<tflite_TensorMap>, tflite_TensorMap>>.self)
    try _v.visit(field: VTOFFSET.signatureKey.p, fieldName: "signatureKey", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.subgraphIndex.p, fieldName: "subgraphIndex", required: false, type: UInt32.self)
    _v.finish()
  }
}

public struct tflite_Model: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "TFL3" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: tflite_Model.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case version = 4
    case operatorCodes = 6
    case subgraphs = 8
    case description = 10
    case buffers = 12
    case metadataBuffer = 14
    case metadata = 16
    case signatureDefs = 18
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var version: UInt32 { let o = _accessor.offset(VTOFFSET.version.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var hasOperatorCodes: Bool { let o = _accessor.offset(VTOFFSET.operatorCodes.v); return o == 0 ? false : true }
  public var operatorCodesCount: Int32 { let o = _accessor.offset(VTOFFSET.operatorCodes.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func operatorCodes(at index: Int32) -> tflite_OperatorCode? { let o = _accessor.offset(VTOFFSET.operatorCodes.v); return o == 0 ? nil : tflite_OperatorCode(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var hasSubgraphs: Bool { let o = _accessor.offset(VTOFFSET.subgraphs.v); return o == 0 ? false : true }
  public var subgraphsCount: Int32 { let o = _accessor.offset(VTOFFSET.subgraphs.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func subgraphs(at index: Int32) -> tflite_SubGraph? { let o = _accessor.offset(VTOFFSET.subgraphs.v); return o == 0 ? nil : tflite_SubGraph(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var description: String? { let o = _accessor.offset(VTOFFSET.description.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var descriptionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.description.v) }
  public var hasBuffers: Bool { let o = _accessor.offset(VTOFFSET.buffers.v); return o == 0 ? false : true }
  public var buffersCount: Int32 { let o = _accessor.offset(VTOFFSET.buffers.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func buffers(at index: Int32) -> tflite_Buffer? { let o = _accessor.offset(VTOFFSET.buffers.v); return o == 0 ? nil : tflite_Buffer(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var hasMetadataBuffer: Bool { let o = _accessor.offset(VTOFFSET.metadataBuffer.v); return o == 0 ? false : true }
  public var metadataBufferCount: Int32 { let o = _accessor.offset(VTOFFSET.metadataBuffer.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func metadataBuffer(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.metadataBuffer.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var metadataBuffer: [Int32] { return _accessor.getVector(at: VTOFFSET.metadataBuffer.v) ?? [] }
  public var hasMetadata: Bool { let o = _accessor.offset(VTOFFSET.metadata.v); return o == 0 ? false : true }
  public var metadataCount: Int32 { let o = _accessor.offset(VTOFFSET.metadata.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func metadata(at index: Int32) -> tflite_Metadata? { let o = _accessor.offset(VTOFFSET.metadata.v); return o == 0 ? nil : tflite_Metadata(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var hasSignatureDefs: Bool { let o = _accessor.offset(VTOFFSET.signatureDefs.v); return o == 0 ? false : true }
  public var signatureDefsCount: Int32 { let o = _accessor.offset(VTOFFSET.signatureDefs.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func signatureDefs(at index: Int32) -> tflite_SignatureDef? { let o = _accessor.offset(VTOFFSET.signatureDefs.v); return o == 0 ? nil : tflite_SignatureDef(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startModel(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 8) }
  public static func add(version: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: version, def: 0, at: VTOFFSET.version.p) }
  public static func addVectorOf(operatorCodes: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: operatorCodes, at: VTOFFSET.operatorCodes.p) }
  public static func addVectorOf(subgraphs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: subgraphs, at: VTOFFSET.subgraphs.p) }
  public static func add(description: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: description, at: VTOFFSET.description.p) }
  public static func addVectorOf(buffers: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: buffers, at: VTOFFSET.buffers.p) }
  public static func addVectorOf(metadataBuffer: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: metadataBuffer, at: VTOFFSET.metadataBuffer.p) }
  public static func addVectorOf(metadata: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: metadata, at: VTOFFSET.metadata.p) }
  public static func addVectorOf(signatureDefs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: signatureDefs, at: VTOFFSET.signatureDefs.p) }
  public static func endModel(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createModel(
    _ fbb: inout FlatBufferBuilder,
    version: UInt32 = 0,
    operatorCodesVectorOffset operatorCodes: Offset = Offset(),
    subgraphsVectorOffset subgraphs: Offset = Offset(),
    descriptionOffset description: Offset = Offset(),
    buffersVectorOffset buffers: Offset = Offset(),
    metadataBufferVectorOffset metadataBuffer: Offset = Offset(),
    metadataVectorOffset metadata: Offset = Offset(),
    signatureDefsVectorOffset signatureDefs: Offset = Offset()
  ) -> Offset {
    let __start = tflite_Model.startModel(&fbb)
    tflite_Model.add(version: version, &fbb)
    tflite_Model.addVectorOf(operatorCodes: operatorCodes, &fbb)
    tflite_Model.addVectorOf(subgraphs: subgraphs, &fbb)
    tflite_Model.add(description: description, &fbb)
    tflite_Model.addVectorOf(buffers: buffers, &fbb)
    tflite_Model.addVectorOf(metadataBuffer: metadataBuffer, &fbb)
    tflite_Model.addVectorOf(metadata: metadata, &fbb)
    tflite_Model.addVectorOf(signatureDefs: signatureDefs, &fbb)
    return tflite_Model.endModel(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.version.p, fieldName: "version", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.operatorCodes.p, fieldName: "operatorCodes", required: false, type: ForwardOffset<Vector<ForwardOffset<tflite_OperatorCode>, tflite_OperatorCode>>.self)
    try _v.visit(field: VTOFFSET.subgraphs.p, fieldName: "subgraphs", required: false, type: ForwardOffset<Vector<ForwardOffset<tflite_SubGraph>, tflite_SubGraph>>.self)
    try _v.visit(field: VTOFFSET.description.p, fieldName: "description", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.buffers.p, fieldName: "buffers", required: false, type: ForwardOffset<Vector<ForwardOffset<tflite_Buffer>, tflite_Buffer>>.self)
    try _v.visit(field: VTOFFSET.metadataBuffer.p, fieldName: "metadataBuffer", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(field: VTOFFSET.metadata.p, fieldName: "metadata", required: false, type: ForwardOffset<Vector<ForwardOffset<tflite_Metadata>, tflite_Metadata>>.self)
    try _v.visit(field: VTOFFSET.signatureDefs.p, fieldName: "signatureDefs", required: false, type: ForwardOffset<Vector<ForwardOffset<tflite_SignatureDef>, tflite_SignatureDef>>.self)
    _v.finish()
  }
}

